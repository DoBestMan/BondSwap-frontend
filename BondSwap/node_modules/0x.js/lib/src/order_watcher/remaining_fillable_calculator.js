"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("@0xproject/utils");
var RemainingFillableCalculator = /** @class */ (function () {
    function RemainingFillableCalculator(signedOrder, isMakerTokenZRX, transferrableMakerTokenAmount, transferrableMakerFeeTokenAmount, remainingMakerTokenAmount) {
        this._signedOrder = signedOrder;
        this._isMakerTokenZRX = isMakerTokenZRX;
        this._transferrableMakerTokenAmount = transferrableMakerTokenAmount;
        this._transferrableMakerFeeTokenAmount = transferrableMakerFeeTokenAmount;
        this._remainingMakerTokenAmount = remainingMakerTokenAmount;
        this._remainingMakerFeeAmount = remainingMakerTokenAmount
            .times(signedOrder.makerFee)
            .dividedToIntegerBy(signedOrder.makerTokenAmount);
    }
    RemainingFillableCalculator.prototype.computeRemainingMakerFillable = function () {
        if (this._hasSufficientFundsForFeeAndTransferAmount()) {
            return this._remainingMakerTokenAmount;
        }
        if (this._signedOrder.makerFee.isZero()) {
            return utils_1.BigNumber.min(this._remainingMakerTokenAmount, this._transferrableMakerTokenAmount);
        }
        return this._calculatePartiallyFillableMakerTokenAmount();
    };
    RemainingFillableCalculator.prototype.computeRemainingTakerFillable = function () {
        return this.computeRemainingMakerFillable()
            .times(this._signedOrder.takerTokenAmount)
            .dividedToIntegerBy(this._signedOrder.makerTokenAmount);
    };
    RemainingFillableCalculator.prototype._hasSufficientFundsForFeeAndTransferAmount = function () {
        if (this._isMakerTokenZRX) {
            var totalZRXTransferAmountRequired = this._remainingMakerTokenAmount.plus(this._remainingMakerFeeAmount);
            var hasSufficientFunds = this._transferrableMakerTokenAmount.greaterThanOrEqualTo(totalZRXTransferAmountRequired);
            return hasSufficientFunds;
        }
        else {
            var hasSufficientFundsForTransferAmount = this._transferrableMakerTokenAmount.greaterThanOrEqualTo(this._remainingMakerTokenAmount);
            var hasSufficientFundsForFeeAmount = this._transferrableMakerFeeTokenAmount.greaterThanOrEqualTo(this._remainingMakerFeeAmount);
            var hasSufficientFunds = hasSufficientFundsForTransferAmount && hasSufficientFundsForFeeAmount;
            return hasSufficientFunds;
        }
    };
    RemainingFillableCalculator.prototype._calculatePartiallyFillableMakerTokenAmount = function () {
        // Given an order for 200 wei for 2 ZRXwei fee, find 100 wei for 1 ZRXwei. Order ratio is then 100:1
        var orderToFeeRatio = this._signedOrder.makerTokenAmount.dividedBy(this._signedOrder.makerFee);
        // The number of times the maker can fill the order, if each fill only required the transfer of a single
        // baseUnit of fee tokens.
        // Given 2 ZRXwei, the maximum amount of times Maker can fill this order, in terms of fees, is 2
        var fillableTimesInFeeTokenBaseUnits = utils_1.BigNumber.min(this._transferrableMakerFeeTokenAmount, this._remainingMakerFeeAmount);
        // The number of times the Maker can fill the order, given the Maker Token Balance
        // Assuming a balance of 150 wei, and an orderToFeeRatio of 100:1, maker can fill this order 1 time.
        var fillableTimesInMakerTokenUnits = this._transferrableMakerTokenAmount.dividedBy(orderToFeeRatio);
        if (this._isMakerTokenZRX) {
            // If ZRX is the maker token, the Fee and the Maker amount need to be removed from the same pool;
            // 200 ZRXwei for 2ZRXwei fee can only be filled once (need 202 ZRXwei)
            var totalZRXTokenPooled = this._transferrableMakerTokenAmount;
            // The purchasing power here is less as the tokens are taken from the same Pool
            // For every one number of fills, we have to take an extra ZRX out of the pool
            fillableTimesInMakerTokenUnits = totalZRXTokenPooled.dividedBy(orderToFeeRatio.plus(new utils_1.BigNumber(1)));
        }
        // When Ratio is not fully divisible there can be remainders which cannot be represented, so they are floored.
        // This can result in a RoundingError being thrown by the Exchange Contract.
        var partiallyFillableMakerTokenAmount = fillableTimesInMakerTokenUnits
            .times(this._signedOrder.makerTokenAmount)
            .dividedToIntegerBy(this._signedOrder.makerFee);
        var partiallyFillableFeeTokenAmount = fillableTimesInFeeTokenBaseUnits
            .times(this._signedOrder.makerTokenAmount)
            .dividedToIntegerBy(this._signedOrder.makerFee);
        var partiallyFillableAmount = utils_1.BigNumber.min(partiallyFillableMakerTokenAmount, partiallyFillableFeeTokenAmount);
        return partiallyFillableAmount;
    };
    return RemainingFillableCalculator;
}());
exports.RemainingFillableCalculator = RemainingFillableCalculator;
//# sourceMappingURL=remaining_fillable_calculator.js.map