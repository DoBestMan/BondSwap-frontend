"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var json_schemas_1 = require("@0xproject/json-schemas");
var utils_1 = require("@0xproject/utils");
var _ = require("lodash");
var _0x_1 = require("../0x");
var balance_proxy_allowance_lazy_store_1 = require("../stores/balance_proxy_allowance_lazy_store");
var order_filled_cancelled_lazy_store_1 = require("../stores/order_filled_cancelled_lazy_store");
var types_1 = require("../types");
var assert_1 = require("../utils/assert");
var order_state_utils_1 = require("../utils/order_state_utils");
var utils_2 = require("../utils/utils");
var event_watcher_1 = require("./event_watcher");
var expiration_watcher_1 = require("./expiration_watcher");
var DEFAULT_CLEANUP_JOB_INTERVAL_MS = 1000 * 60 * 60; // 1h
/**
 * This class includes all the functionality related to watching a set of orders
 * for potential changes in order validity/fillability. The orderWatcher notifies
 * the subscriber of these changes so that a final decison can be made on whether
 * the order should be deemed invalid.
 */
var OrderStateWatcher = /** @class */ (function () {
    function OrderStateWatcher(web3Wrapper, abiDecoder, token, exchange, config) {
        this._orderStateByOrderHashCache = {};
        this._orderByOrderHash = {};
        this._dependentOrderHashes = {};
        this._abiDecoder = abiDecoder;
        this._web3Wrapper = web3Wrapper;
        var pollingIntervalIfExistsMs = _.isUndefined(config) ? undefined : config.eventPollingIntervalMs;
        this._eventWatcher = new event_watcher_1.EventWatcher(web3Wrapper, pollingIntervalIfExistsMs);
        this._balanceAndProxyAllowanceLazyStore = new balance_proxy_allowance_lazy_store_1.BalanceAndProxyAllowanceLazyStore(token, types_1.BlockParamLiteral.Pending);
        this._orderFilledCancelledLazyStore = new order_filled_cancelled_lazy_store_1.OrderFilledCancelledLazyStore(exchange);
        this._orderStateUtils = new order_state_utils_1.OrderStateUtils(this._balanceAndProxyAllowanceLazyStore, this._orderFilledCancelledLazyStore);
        var orderExpirationCheckingIntervalMsIfExists = _.isUndefined(config)
            ? undefined
            : config.orderExpirationCheckingIntervalMs;
        var expirationMarginIfExistsMs = _.isUndefined(config) ? undefined : config.expirationMarginMs;
        this._expirationWatcher = new expiration_watcher_1.ExpirationWatcher(expirationMarginIfExistsMs, orderExpirationCheckingIntervalMsIfExists);
        this._cleanupJobInterval =
            _.isUndefined(config) || _.isUndefined(config.cleanupJobIntervalMs)
                ? DEFAULT_CLEANUP_JOB_INTERVAL_MS
                : config.cleanupJobIntervalMs;
    }
    /**
     * Add an order to the orderStateWatcher. Before the order is added, it's
     * signature is verified.
     * @param   signedOrder     The order you wish to start watching.
     */
    OrderStateWatcher.prototype.addOrder = function (signedOrder) {
        assert_1.assert.doesConformToSchema('signedOrder', signedOrder, json_schemas_1.schemas.signedOrderSchema);
        var orderHash = _0x_1.ZeroEx.getOrderHashHex(signedOrder);
        assert_1.assert.isValidSignature(orderHash, signedOrder.ecSignature, signedOrder.maker);
        this._orderByOrderHash[orderHash] = signedOrder;
        this._addToDependentOrderHashes(signedOrder, orderHash);
        var expirationUnixTimestampMs = signedOrder.expirationUnixTimestampSec.times(1000);
        this._expirationWatcher.addOrder(orderHash, expirationUnixTimestampMs);
    };
    /**
     * Removes an order from the orderStateWatcher
     * @param   orderHash     The orderHash of the order you wish to stop watching.
     */
    OrderStateWatcher.prototype.removeOrder = function (orderHash) {
        assert_1.assert.doesConformToSchema('orderHash', orderHash, json_schemas_1.schemas.orderHashSchema);
        var signedOrder = this._orderByOrderHash[orderHash];
        if (_.isUndefined(signedOrder)) {
            return; // noop
        }
        delete this._orderByOrderHash[orderHash];
        delete this._orderStateByOrderHashCache[orderHash];
        var exchange = this._orderFilledCancelledLazyStore._exchange;
        var zrxTokenAddress = exchange.getZRXTokenAddress();
        this._removeFromDependentOrderHashes(signedOrder.maker, zrxTokenAddress, orderHash);
        this._removeFromDependentOrderHashes(signedOrder.maker, signedOrder.makerTokenAddress, orderHash);
        this._expirationWatcher.removeOrder(orderHash);
    };
    /**
     * Starts an orderStateWatcher subscription. The callback will be called every time a watched order's
     * backing blockchain state has changed. This is a call-to-action for the caller to re-validate the order.
     * @param   callback            Receives the orderHash of the order that should be re-validated, together
     *                              with all the order-relevant blockchain state needed to re-validate the order.
     */
    OrderStateWatcher.prototype.subscribe = function (callback) {
        assert_1.assert.isFunction('callback', callback);
        if (!_.isUndefined(this._callbackIfExists)) {
            throw new Error(types_1.ZeroExError.SubscriptionAlreadyPresent);
        }
        this._callbackIfExists = callback;
        this._eventWatcher.subscribe(this._onEventWatcherCallbackAsync.bind(this));
        this._expirationWatcher.subscribe(this._onOrderExpired.bind(this));
        this._cleanupJobIntervalIdIfExists = utils_1.intervalUtils.setAsyncExcludingInterval(this._cleanupAsync.bind(this), this._cleanupJobInterval);
    };
    /**
     * Ends an orderStateWatcher subscription.
     */
    OrderStateWatcher.prototype.unsubscribe = function () {
        if (_.isUndefined(this._callbackIfExists) || _.isUndefined(this._cleanupJobIntervalIdIfExists)) {
            throw new Error(types_1.ZeroExError.SubscriptionNotFound);
        }
        this._balanceAndProxyAllowanceLazyStore.deleteAll();
        this._orderFilledCancelledLazyStore.deleteAll();
        delete this._callbackIfExists;
        this._eventWatcher.unsubscribe();
        this._expirationWatcher.unsubscribe();
        utils_1.intervalUtils.clearAsyncExcludingInterval(this._cleanupJobIntervalIdIfExists);
    };
    OrderStateWatcher.prototype._cleanupAsync = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _i, _a, orderHash;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _i = 0, _a = _.keys(this._orderByOrderHash);
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 4];
                        orderHash = _a[_i];
                        this._cleanupOrderRelatedState(orderHash);
                        return [4 /*yield*/, this._emitRevalidateOrdersAsync([orderHash])];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    OrderStateWatcher.prototype._cleanupOrderRelatedState = function (orderHash) {
        var signedOrder = this._orderByOrderHash[orderHash];
        this._orderFilledCancelledLazyStore.deleteFilledTakerAmount(orderHash);
        this._orderFilledCancelledLazyStore.deleteCancelledTakerAmount(orderHash);
        this._balanceAndProxyAllowanceLazyStore.deleteBalance(signedOrder.makerTokenAddress, signedOrder.maker);
        this._balanceAndProxyAllowanceLazyStore.deleteProxyAllowance(signedOrder.makerTokenAddress, signedOrder.maker);
        this._balanceAndProxyAllowanceLazyStore.deleteBalance(signedOrder.takerTokenAddress, signedOrder.taker);
        this._balanceAndProxyAllowanceLazyStore.deleteProxyAllowance(signedOrder.takerTokenAddress, signedOrder.taker);
        var zrxTokenAddress = this._getZRXTokenAddress();
        if (!signedOrder.makerFee.isZero()) {
            this._balanceAndProxyAllowanceLazyStore.deleteBalance(zrxTokenAddress, signedOrder.maker);
            this._balanceAndProxyAllowanceLazyStore.deleteProxyAllowance(zrxTokenAddress, signedOrder.maker);
        }
        if (!signedOrder.takerFee.isZero()) {
            this._balanceAndProxyAllowanceLazyStore.deleteBalance(zrxTokenAddress, signedOrder.taker);
            this._balanceAndProxyAllowanceLazyStore.deleteProxyAllowance(zrxTokenAddress, signedOrder.taker);
        }
    };
    OrderStateWatcher.prototype._onOrderExpired = function (orderHash) {
        var orderState = {
            isValid: false,
            orderHash: orderHash,
            error: types_1.ExchangeContractErrs.OrderFillExpired,
        };
        if (!_.isUndefined(this._orderByOrderHash[orderHash])) {
            this.removeOrder(orderHash);
            if (!_.isUndefined(this._callbackIfExists)) {
                this._callbackIfExists(orderState);
            }
        }
    };
    OrderStateWatcher.prototype._onEventWatcherCallbackAsync = function (log) {
        return __awaiter(this, void 0, void 0, function () {
            var maybeDecodedLog, isLogDecoded, decodedLog, makerToken, makerAddress, _a, args, orderHashes, args, orderHashes, args, orderHashes, args, orderHashes, args, orderHash, isOrderWatched, args, orderHash, isOrderWatched;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        maybeDecodedLog = this._abiDecoder.tryToDecodeLogOrNoop(log);
                        isLogDecoded = !_.isUndefined(maybeDecodedLog.event);
                        if (!isLogDecoded) {
                            return [2 /*return*/]; // noop
                        }
                        decodedLog = maybeDecodedLog;
                        _a = decodedLog.event;
                        switch (_a) {
                            case types_1.TokenEvents.Approval: return [3 /*break*/, 1];
                            case types_1.TokenEvents.Transfer: return [3 /*break*/, 4];
                            case types_1.EtherTokenEvents.Deposit: return [3 /*break*/, 7];
                            case types_1.EtherTokenEvents.Withdrawal: return [3 /*break*/, 10];
                            case types_1.ExchangeEvents.LogFill: return [3 /*break*/, 13];
                            case types_1.ExchangeEvents.LogCancel: return [3 /*break*/, 16];
                            case types_1.ExchangeEvents.LogError: return [3 /*break*/, 19];
                        }
                        return [3 /*break*/, 20];
                    case 1:
                        args = decodedLog.args;
                        this._balanceAndProxyAllowanceLazyStore.deleteProxyAllowance(decodedLog.address, args._owner);
                        // Revalidate orders
                        makerToken = decodedLog.address;
                        makerAddress = args._owner;
                        if (!(!_.isUndefined(this._dependentOrderHashes[makerAddress]) &&
                            !_.isUndefined(this._dependentOrderHashes[makerAddress][makerToken]))) return [3 /*break*/, 3];
                        orderHashes = Array.from(this._dependentOrderHashes[makerAddress][makerToken]);
                        return [4 /*yield*/, this._emitRevalidateOrdersAsync(orderHashes)];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3: return [3 /*break*/, 21];
                    case 4:
                        args = decodedLog.args;
                        this._balanceAndProxyAllowanceLazyStore.deleteBalance(decodedLog.address, args._from);
                        this._balanceAndProxyAllowanceLazyStore.deleteBalance(decodedLog.address, args._to);
                        // Revalidate orders
                        makerToken = decodedLog.address;
                        makerAddress = args._from;
                        if (!(!_.isUndefined(this._dependentOrderHashes[makerAddress]) &&
                            !_.isUndefined(this._dependentOrderHashes[makerAddress][makerToken]))) return [3 /*break*/, 6];
                        orderHashes = Array.from(this._dependentOrderHashes[makerAddress][makerToken]);
                        return [4 /*yield*/, this._emitRevalidateOrdersAsync(orderHashes)];
                    case 5:
                        _b.sent();
                        _b.label = 6;
                    case 6: return [3 /*break*/, 21];
                    case 7:
                        args = decodedLog.args;
                        this._balanceAndProxyAllowanceLazyStore.deleteBalance(decodedLog.address, args._owner);
                        // Revalidate orders
                        makerToken = decodedLog.address;
                        makerAddress = args._owner;
                        if (!(!_.isUndefined(this._dependentOrderHashes[makerAddress]) &&
                            !_.isUndefined(this._dependentOrderHashes[makerAddress][makerToken]))) return [3 /*break*/, 9];
                        orderHashes = Array.from(this._dependentOrderHashes[makerAddress][makerToken]);
                        return [4 /*yield*/, this._emitRevalidateOrdersAsync(orderHashes)];
                    case 8:
                        _b.sent();
                        _b.label = 9;
                    case 9: return [3 /*break*/, 21];
                    case 10:
                        args = decodedLog.args;
                        this._balanceAndProxyAllowanceLazyStore.deleteBalance(decodedLog.address, args._owner);
                        // Revalidate orders
                        makerToken = decodedLog.address;
                        makerAddress = args._owner;
                        if (!(!_.isUndefined(this._dependentOrderHashes[makerAddress]) &&
                            !_.isUndefined(this._dependentOrderHashes[makerAddress][makerToken]))) return [3 /*break*/, 12];
                        orderHashes = Array.from(this._dependentOrderHashes[makerAddress][makerToken]);
                        return [4 /*yield*/, this._emitRevalidateOrdersAsync(orderHashes)];
                    case 11:
                        _b.sent();
                        _b.label = 12;
                    case 12: return [3 /*break*/, 21];
                    case 13:
                        args = decodedLog.args;
                        this._orderFilledCancelledLazyStore.deleteFilledTakerAmount(args.orderHash);
                        orderHash = args.orderHash;
                        isOrderWatched = !_.isUndefined(this._orderByOrderHash[orderHash]);
                        if (!isOrderWatched) return [3 /*break*/, 15];
                        return [4 /*yield*/, this._emitRevalidateOrdersAsync([orderHash])];
                    case 14:
                        _b.sent();
                        _b.label = 15;
                    case 15: return [3 /*break*/, 21];
                    case 16:
                        args = decodedLog.args;
                        this._orderFilledCancelledLazyStore.deleteCancelledTakerAmount(args.orderHash);
                        orderHash = args.orderHash;
                        isOrderWatched = !_.isUndefined(this._orderByOrderHash[orderHash]);
                        if (!isOrderWatched) return [3 /*break*/, 18];
                        return [4 /*yield*/, this._emitRevalidateOrdersAsync([orderHash])];
                    case 17:
                        _b.sent();
                        _b.label = 18;
                    case 18: return [3 /*break*/, 21];
                    case 19: return [2 /*return*/]; // noop
                    case 20: throw utils_2.utils.spawnSwitchErr('decodedLog.event', decodedLog.event);
                    case 21: return [2 /*return*/];
                }
            });
        });
    };
    OrderStateWatcher.prototype._emitRevalidateOrdersAsync = function (orderHashes) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, orderHashes_1, orderHash, signedOrder, orderState;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _i = 0, orderHashes_1 = orderHashes;
                        _a.label = 1;
                    case 1:
                        if (!(_i < orderHashes_1.length)) return [3 /*break*/, 4];
                        orderHash = orderHashes_1[_i];
                        signedOrder = this._orderByOrderHash[orderHash];
                        return [4 /*yield*/, this._orderStateUtils.getOrderStateAsync(signedOrder)];
                    case 2:
                        orderState = _a.sent();
                        if (_.isUndefined(this._callbackIfExists)) {
                            return [3 /*break*/, 4]; // Unsubscribe was called
                        }
                        if (_.isEqual(orderState, this._orderStateByOrderHashCache[orderHash])) {
                            // Actual order state didn't change
                            return [3 /*break*/, 3];
                        }
                        else {
                            this._orderStateByOrderHashCache[orderHash] = orderState;
                        }
                        this._callbackIfExists(orderState);
                        _a.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    OrderStateWatcher.prototype._addToDependentOrderHashes = function (signedOrder, orderHash) {
        if (_.isUndefined(this._dependentOrderHashes[signedOrder.maker])) {
            this._dependentOrderHashes[signedOrder.maker] = {};
        }
        if (_.isUndefined(this._dependentOrderHashes[signedOrder.maker][signedOrder.makerTokenAddress])) {
            this._dependentOrderHashes[signedOrder.maker][signedOrder.makerTokenAddress] = new Set();
        }
        this._dependentOrderHashes[signedOrder.maker][signedOrder.makerTokenAddress].add(orderHash);
        var zrxTokenAddress = this._getZRXTokenAddress();
        if (_.isUndefined(this._dependentOrderHashes[signedOrder.maker][zrxTokenAddress])) {
            this._dependentOrderHashes[signedOrder.maker][zrxTokenAddress] = new Set();
        }
        this._dependentOrderHashes[signedOrder.maker][zrxTokenAddress].add(orderHash);
    };
    OrderStateWatcher.prototype._removeFromDependentOrderHashes = function (makerAddress, tokenAddress, orderHash) {
        this._dependentOrderHashes[makerAddress][tokenAddress].delete(orderHash);
        if (this._dependentOrderHashes[makerAddress][tokenAddress].size === 0) {
            delete this._dependentOrderHashes[makerAddress][tokenAddress];
        }
        if (_.isEmpty(this._dependentOrderHashes[makerAddress])) {
            delete this._dependentOrderHashes[makerAddress];
        }
    };
    OrderStateWatcher.prototype._getZRXTokenAddress = function () {
        var exchange = this._orderFilledCancelledLazyStore._exchange;
        var zrxTokenAddress = exchange.getZRXTokenAddress();
        return zrxTokenAddress;
    };
    return OrderStateWatcher;
}());
exports.OrderStateWatcher = OrderStateWatcher;
//# sourceMappingURL=order_state_watcher.js.map