"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var dev_utils_1 = require("@0xproject/dev-utils");
var utils_1 = require("@0xproject/utils");
var chai = require("chai");
var _ = require("lodash");
require("mocha");
var src_1 = require("../src");
var chai_setup_1 = require("./utils/chai_setup");
var constants_1 = require("./utils/constants");
var fill_scenarios_1 = require("./utils/fill_scenarios");
var report_callback_errors_1 = require("./utils/report_callback_errors");
var token_utils_1 = require("./utils/token_utils");
var web3_factory_1 = require("./utils/web3_factory");
var TIMEOUT_MS = 150;
chai_setup_1.chaiSetup.configure();
var expect = chai.expect;
var blockchainLifecycle = new dev_utils_1.BlockchainLifecycle(constants_1.constants.RPC_URL);
describe('OrderStateWatcher', function () {
    var web3;
    var zeroEx;
    var tokens;
    var tokenUtils;
    var fillScenarios;
    var userAddresses;
    var zrxTokenAddress;
    var exchangeContractAddress;
    var makerToken;
    var takerToken;
    var maker;
    var taker;
    var signedOrder;
    var config = {
        networkId: constants_1.constants.TESTRPC_NETWORK_ID,
    };
    var decimals = constants_1.constants.ZRX_DECIMALS;
    var fillableAmount = src_1.ZeroEx.toBaseUnitAmount(new utils_1.BigNumber(5), decimals);
    before(function () { return __awaiter(_this, void 0, void 0, function () {
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    web3 = web3_factory_1.web3Factory.create();
                    zeroEx = new src_1.ZeroEx(web3.currentProvider, config);
                    exchangeContractAddress = zeroEx.exchange.getContractAddress();
                    return [4 /*yield*/, zeroEx.getAvailableAddressesAsync()];
                case 1:
                    userAddresses = _b.sent();
                    maker = userAddresses[1], taker = userAddresses[2];
                    return [4 /*yield*/, zeroEx.tokenRegistry.getTokensAsync()];
                case 2:
                    tokens = _b.sent();
                    tokenUtils = new token_utils_1.TokenUtils(tokens);
                    zrxTokenAddress = tokenUtils.getProtocolTokenOrThrow().address;
                    fillScenarios = new fill_scenarios_1.FillScenarios(zeroEx, userAddresses, tokens, zrxTokenAddress, exchangeContractAddress);
                    return [4 /*yield*/, fillScenarios.initTokenBalancesAsync()];
                case 3:
                    _b.sent();
                    _a = tokenUtils.getDummyTokens(), makerToken = _a[0], takerToken = _a[1];
                    return [2 /*return*/];
            }
        });
    }); });
    beforeEach(function () { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, blockchainLifecycle.startAsync()];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    }); });
    afterEach(function () { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, blockchainLifecycle.revertAsync()];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    }); });
    describe('#removeOrder', function () { return __awaiter(_this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_a) {
            it('should successfully remove existing order', function () { return __awaiter(_this, void 0, void 0, function () {
                var orderHash, dependentOrderHashes, _a, _b;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerToken.address, takerToken.address, maker, taker, fillableAmount)];
                        case 1:
                            signedOrder = _c.sent();
                            orderHash = src_1.ZeroEx.getOrderHashHex(signedOrder);
                            zeroEx.orderStateWatcher.addOrder(signedOrder);
                            expect(zeroEx.orderStateWatcher._orderByOrderHash).to.include((_a = {},
                                _a[orderHash] = signedOrder,
                                _a));
                            dependentOrderHashes = zeroEx.orderStateWatcher._dependentOrderHashes;
                            expect(dependentOrderHashes[signedOrder.maker][signedOrder.makerTokenAddress]).to.have.keys(orderHash);
                            zeroEx.orderStateWatcher.removeOrder(orderHash);
                            expect(zeroEx.orderStateWatcher._orderByOrderHash).to.not.include((_b = {},
                                _b[orderHash] = signedOrder,
                                _b));
                            dependentOrderHashes = zeroEx.orderStateWatcher._dependentOrderHashes;
                            expect(dependentOrderHashes[signedOrder.maker]).to.be.undefined();
                            return [2 /*return*/];
                    }
                });
            }); });
            it('should no-op when removing a non-existing order', function () { return __awaiter(_this, void 0, void 0, function () {
                var orderHash, nonExistentOrderHash;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerToken.address, takerToken.address, maker, taker, fillableAmount)];
                        case 1:
                            signedOrder = _a.sent();
                            orderHash = src_1.ZeroEx.getOrderHashHex(signedOrder);
                            nonExistentOrderHash = "0x" + orderHash
                                .substr(2)
                                .split('')
                                .reverse()
                                .join('');
                            zeroEx.orderStateWatcher.removeOrder(nonExistentOrderHash);
                            return [2 /*return*/];
                    }
                });
            }); });
            return [2 /*return*/];
        });
    }); });
    describe('#subscribe', function () { return __awaiter(_this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_a) {
            afterEach(function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    zeroEx.orderStateWatcher.unsubscribe();
                    return [2 /*return*/];
                });
            }); });
            it('should fail when trying to subscribe twice', function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    zeroEx.orderStateWatcher.subscribe(_.noop);
                    expect(function () { return zeroEx.orderStateWatcher.subscribe(_.noop); }).to.throw(src_1.ZeroExError.SubscriptionAlreadyPresent);
                    return [2 /*return*/];
                });
            }); });
            return [2 /*return*/];
        });
    }); });
    describe('tests with cleanup', function () { return __awaiter(_this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_a) {
            afterEach(function () { return __awaiter(_this, void 0, void 0, function () {
                var orderHash;
                return __generator(this, function (_a) {
                    zeroEx.orderStateWatcher.unsubscribe();
                    orderHash = src_1.ZeroEx.getOrderHashHex(signedOrder);
                    zeroEx.orderStateWatcher.removeOrder(orderHash);
                    return [2 /*return*/];
                });
            }); });
            it('should emit orderStateInvalid when maker allowance set to 0 for watched order', function (done) {
                (function () { return __awaiter(_this, void 0, void 0, function () {
                    var orderHash, callback;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerToken.address, takerToken.address, maker, taker, fillableAmount)];
                            case 1:
                                signedOrder = _a.sent();
                                orderHash = src_1.ZeroEx.getOrderHashHex(signedOrder);
                                zeroEx.orderStateWatcher.addOrder(signedOrder);
                                callback = report_callback_errors_1.reportNoErrorCallbackErrors(done)(function (orderState) {
                                    expect(orderState.isValid).to.be.false();
                                    var invalidOrderState = orderState;
                                    expect(invalidOrderState.orderHash).to.be.equal(orderHash);
                                    expect(invalidOrderState.error).to.be.equal(src_1.ExchangeContractErrs.InsufficientMakerAllowance);
                                });
                                zeroEx.orderStateWatcher.subscribe(callback);
                                return [4 /*yield*/, zeroEx.token.setProxyAllowanceAsync(makerToken.address, maker, new utils_1.BigNumber(0))];
                            case 2:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                }); })().catch(done);
            });
            it('should not emit an orderState event when irrelevant Transfer event received', function (done) {
                (function () { return __awaiter(_this, void 0, void 0, function () {
                    var callback, notTheMaker, anyRecipient, transferAmount;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerToken.address, takerToken.address, maker, taker, fillableAmount)];
                            case 1:
                                signedOrder = _a.sent();
                                zeroEx.orderStateWatcher.addOrder(signedOrder);
                                callback = report_callback_errors_1.reportNoErrorCallbackErrors(done)(function (orderState) {
                                    throw new Error('OrderState callback fired for irrelevant order');
                                });
                                zeroEx.orderStateWatcher.subscribe(callback);
                                notTheMaker = userAddresses[0];
                                anyRecipient = taker;
                                transferAmount = new utils_1.BigNumber(2);
                                return [4 /*yield*/, zeroEx.token.transferAsync(makerToken.address, notTheMaker, anyRecipient, transferAmount)];
                            case 2:
                                _a.sent();
                                setTimeout(function () {
                                    done();
                                }, TIMEOUT_MS);
                                return [2 /*return*/];
                        }
                    });
                }); })().catch(done);
            });
            it('should emit orderStateInvalid when maker moves balance backing watched order', function (done) {
                (function () { return __awaiter(_this, void 0, void 0, function () {
                    var orderHash, callback, anyRecipient, makerBalance;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerToken.address, takerToken.address, maker, taker, fillableAmount)];
                            case 1:
                                signedOrder = _a.sent();
                                orderHash = src_1.ZeroEx.getOrderHashHex(signedOrder);
                                zeroEx.orderStateWatcher.addOrder(signedOrder);
                                callback = report_callback_errors_1.reportNoErrorCallbackErrors(done)(function (orderState) {
                                    expect(orderState.isValid).to.be.false();
                                    var invalidOrderState = orderState;
                                    expect(invalidOrderState.orderHash).to.be.equal(orderHash);
                                    expect(invalidOrderState.error).to.be.equal(src_1.ExchangeContractErrs.InsufficientMakerBalance);
                                });
                                zeroEx.orderStateWatcher.subscribe(callback);
                                anyRecipient = taker;
                                return [4 /*yield*/, zeroEx.token.getBalanceAsync(makerToken.address, maker)];
                            case 2:
                                makerBalance = _a.sent();
                                return [4 /*yield*/, zeroEx.token.transferAsync(makerToken.address, maker, anyRecipient, makerBalance)];
                            case 3:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                }); })().catch(done);
            });
            it('should emit orderStateInvalid when watched order fully filled', function (done) {
                (function () { return __awaiter(_this, void 0, void 0, function () {
                    var orderHash, callback, shouldThrowOnInsufficientBalanceOrAllowance;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerToken.address, takerToken.address, maker, taker, fillableAmount)];
                            case 1:
                                signedOrder = _a.sent();
                                orderHash = src_1.ZeroEx.getOrderHashHex(signedOrder);
                                zeroEx.orderStateWatcher.addOrder(signedOrder);
                                callback = report_callback_errors_1.reportNoErrorCallbackErrors(done)(function (orderState) {
                                    expect(orderState.isValid).to.be.false();
                                    var invalidOrderState = orderState;
                                    expect(invalidOrderState.orderHash).to.be.equal(orderHash);
                                    expect(invalidOrderState.error).to.be.equal(src_1.ExchangeContractErrs.OrderRemainingFillAmountZero);
                                });
                                zeroEx.orderStateWatcher.subscribe(callback);
                                shouldThrowOnInsufficientBalanceOrAllowance = true;
                                return [4 /*yield*/, zeroEx.exchange.fillOrderAsync(signedOrder, fillableAmount, shouldThrowOnInsufficientBalanceOrAllowance, taker)];
                            case 2:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                }); })().catch(done);
            });
            it('should emit orderStateValid when watched order partially filled', function (done) {
                (function () { return __awaiter(_this, void 0, void 0, function () {
                    var makerBalance, fillAmountInBaseUnits, orderHash, callback, shouldThrowOnInsufficientBalanceOrAllowance;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerToken.address, takerToken.address, maker, taker, fillableAmount)];
                            case 1:
                                signedOrder = _a.sent();
                                return [4 /*yield*/, zeroEx.token.getBalanceAsync(makerToken.address, maker)];
                            case 2:
                                makerBalance = _a.sent();
                                fillAmountInBaseUnits = new utils_1.BigNumber(2);
                                orderHash = src_1.ZeroEx.getOrderHashHex(signedOrder);
                                zeroEx.orderStateWatcher.addOrder(signedOrder);
                                callback = report_callback_errors_1.reportNoErrorCallbackErrors(done)(function (orderState) {
                                    expect(orderState.isValid).to.be.true();
                                    var validOrderState = orderState;
                                    expect(validOrderState.orderHash).to.be.equal(orderHash);
                                    var orderRelevantState = validOrderState.orderRelevantState;
                                    var remainingMakerBalance = makerBalance.sub(fillAmountInBaseUnits);
                                    var remainingFillable = fillableAmount.minus(fillAmountInBaseUnits);
                                    expect(orderRelevantState.remainingFillableMakerTokenAmount).to.be.bignumber.equal(remainingFillable);
                                    expect(orderRelevantState.remainingFillableTakerTokenAmount).to.be.bignumber.equal(remainingFillable);
                                    expect(orderRelevantState.makerBalance).to.be.bignumber.equal(remainingMakerBalance);
                                });
                                zeroEx.orderStateWatcher.subscribe(callback);
                                shouldThrowOnInsufficientBalanceOrAllowance = true;
                                return [4 /*yield*/, zeroEx.exchange.fillOrderAsync(signedOrder, fillAmountInBaseUnits, shouldThrowOnInsufficientBalanceOrAllowance, taker)];
                            case 3:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                }); })().catch(done);
            });
            it('should trigger the callback when orders backing ZRX allowance changes', function (done) {
                (function () { return __awaiter(_this, void 0, void 0, function () {
                    var makerFee, takerFee, callback;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                makerFee = src_1.ZeroEx.toBaseUnitAmount(new utils_1.BigNumber(2), 18);
                                takerFee = src_1.ZeroEx.toBaseUnitAmount(new utils_1.BigNumber(0), 18);
                                return [4 /*yield*/, fillScenarios.createFillableSignedOrderWithFeesAsync(makerToken.address, takerToken.address, makerFee, takerFee, maker, taker, fillableAmount, taker)];
                            case 1:
                                signedOrder = _a.sent();
                                callback = report_callback_errors_1.reportNoErrorCallbackErrors(done)();
                                zeroEx.orderStateWatcher.addOrder(signedOrder);
                                zeroEx.orderStateWatcher.subscribe(callback);
                                return [4 /*yield*/, zeroEx.token.setProxyAllowanceAsync(zrxTokenAddress, maker, new utils_1.BigNumber(0))];
                            case 2:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                }); })().catch(done);
            });
            describe('remainingFillable(M|T)akerTokenAmount', function () {
                it('should calculate correct remaining fillable', function (done) {
                    (function () { return __awaiter(_this, void 0, void 0, function () {
                        var takerFillableAmount, makerFillableAmount, fillAmountInBaseUnits, orderHash, callback, shouldThrowOnInsufficientBalanceOrAllowance;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    takerFillableAmount = src_1.ZeroEx.toBaseUnitAmount(new utils_1.BigNumber(10), decimals);
                                    makerFillableAmount = src_1.ZeroEx.toBaseUnitAmount(new utils_1.BigNumber(20), decimals);
                                    return [4 /*yield*/, fillScenarios.createAsymmetricFillableSignedOrderAsync(makerToken.address, takerToken.address, maker, taker, makerFillableAmount, takerFillableAmount)];
                                case 1:
                                    signedOrder = _a.sent();
                                    fillAmountInBaseUnits = src_1.ZeroEx.toBaseUnitAmount(new utils_1.BigNumber(2), decimals);
                                    orderHash = src_1.ZeroEx.getOrderHashHex(signedOrder);
                                    zeroEx.orderStateWatcher.addOrder(signedOrder);
                                    callback = report_callback_errors_1.reportNoErrorCallbackErrors(done)(function (orderState) {
                                        expect(orderState.isValid).to.be.true();
                                        var validOrderState = orderState;
                                        expect(validOrderState.orderHash).to.be.equal(orderHash);
                                        var orderRelevantState = validOrderState.orderRelevantState;
                                        expect(orderRelevantState.remainingFillableMakerTokenAmount).to.be.bignumber.equal(src_1.ZeroEx.toBaseUnitAmount(new utils_1.BigNumber(16), decimals));
                                        expect(orderRelevantState.remainingFillableTakerTokenAmount).to.be.bignumber.equal(src_1.ZeroEx.toBaseUnitAmount(new utils_1.BigNumber(8), decimals));
                                    });
                                    zeroEx.orderStateWatcher.subscribe(callback);
                                    shouldThrowOnInsufficientBalanceOrAllowance = true;
                                    return [4 /*yield*/, zeroEx.exchange.fillOrderAsync(signedOrder, fillAmountInBaseUnits, shouldThrowOnInsufficientBalanceOrAllowance, taker)];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); })().catch(done);
                });
                it('should equal approved amount when approved amount is lowest', function (done) {
                    (function () { return __awaiter(_this, void 0, void 0, function () {
                        var changedMakerApprovalAmount, callback;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerToken.address, takerToken.address, maker, taker, fillableAmount)];
                                case 1:
                                    signedOrder = _a.sent();
                                    changedMakerApprovalAmount = src_1.ZeroEx.toBaseUnitAmount(new utils_1.BigNumber(3), decimals);
                                    zeroEx.orderStateWatcher.addOrder(signedOrder);
                                    callback = report_callback_errors_1.reportNoErrorCallbackErrors(done)(function (orderState) {
                                        var validOrderState = orderState;
                                        var orderRelevantState = validOrderState.orderRelevantState;
                                        expect(orderRelevantState.remainingFillableMakerTokenAmount).to.be.bignumber.equal(changedMakerApprovalAmount);
                                        expect(orderRelevantState.remainingFillableTakerTokenAmount).to.be.bignumber.equal(changedMakerApprovalAmount);
                                    });
                                    zeroEx.orderStateWatcher.subscribe(callback);
                                    return [4 /*yield*/, zeroEx.token.setProxyAllowanceAsync(makerToken.address, maker, changedMakerApprovalAmount)];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); })().catch(done);
                });
                it('should equal balance amount when balance amount is lowest', function (done) {
                    (function () { return __awaiter(_this, void 0, void 0, function () {
                        var makerBalance, remainingAmount, transferAmount, callback;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerToken.address, takerToken.address, maker, taker, fillableAmount)];
                                case 1:
                                    signedOrder = _a.sent();
                                    return [4 /*yield*/, zeroEx.token.getBalanceAsync(makerToken.address, maker)];
                                case 2:
                                    makerBalance = _a.sent();
                                    remainingAmount = src_1.ZeroEx.toBaseUnitAmount(new utils_1.BigNumber(1), decimals);
                                    transferAmount = makerBalance.sub(remainingAmount);
                                    zeroEx.orderStateWatcher.addOrder(signedOrder);
                                    callback = report_callback_errors_1.reportNoErrorCallbackErrors(done)(function (orderState) {
                                        expect(orderState.isValid).to.be.true();
                                        var validOrderState = orderState;
                                        var orderRelevantState = validOrderState.orderRelevantState;
                                        expect(orderRelevantState.remainingFillableMakerTokenAmount).to.be.bignumber.equal(remainingAmount);
                                        expect(orderRelevantState.remainingFillableTakerTokenAmount).to.be.bignumber.equal(remainingAmount);
                                    });
                                    zeroEx.orderStateWatcher.subscribe(callback);
                                    return [4 /*yield*/, zeroEx.token.transferAsync(makerToken.address, maker, src_1.ZeroEx.NULL_ADDRESS, transferAmount)];
                                case 3:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); })().catch(done);
                });
                it('should equal remaining amount when partially cancelled and order has fees', function (done) {
                    (function () { return __awaiter(_this, void 0, void 0, function () {
                        var takerFee, makerFee, feeRecipient, remainingTokenAmount, transferTokenAmount, callback;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    takerFee = src_1.ZeroEx.toBaseUnitAmount(new utils_1.BigNumber(0), decimals);
                                    makerFee = src_1.ZeroEx.toBaseUnitAmount(new utils_1.BigNumber(5), decimals);
                                    feeRecipient = taker;
                                    return [4 /*yield*/, fillScenarios.createFillableSignedOrderWithFeesAsync(makerToken.address, takerToken.address, makerFee, takerFee, maker, taker, fillableAmount, feeRecipient)];
                                case 1:
                                    signedOrder = _a.sent();
                                    remainingTokenAmount = src_1.ZeroEx.toBaseUnitAmount(new utils_1.BigNumber(4), decimals);
                                    transferTokenAmount = makerFee.sub(remainingTokenAmount);
                                    zeroEx.orderStateWatcher.addOrder(signedOrder);
                                    callback = report_callback_errors_1.reportNoErrorCallbackErrors(done)(function (orderState) {
                                        expect(orderState.isValid).to.be.true();
                                        var validOrderState = orderState;
                                        var orderRelevantState = validOrderState.orderRelevantState;
                                        expect(orderRelevantState.remainingFillableMakerTokenAmount).to.be.bignumber.equal(remainingTokenAmount);
                                    });
                                    zeroEx.orderStateWatcher.subscribe(callback);
                                    return [4 /*yield*/, zeroEx.exchange.cancelOrderAsync(signedOrder, transferTokenAmount)];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); })().catch(done);
                });
                it('should equal ratio amount when fee balance is lowered', function (done) {
                    (function () { return __awaiter(_this, void 0, void 0, function () {
                        var takerFee, makerFee, feeRecipient, remainingFeeAmount, remainingTokenAmount, transferTokenAmount, callback;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    takerFee = src_1.ZeroEx.toBaseUnitAmount(new utils_1.BigNumber(0), decimals);
                                    makerFee = src_1.ZeroEx.toBaseUnitAmount(new utils_1.BigNumber(5), decimals);
                                    feeRecipient = taker;
                                    return [4 /*yield*/, fillScenarios.createFillableSignedOrderWithFeesAsync(makerToken.address, takerToken.address, makerFee, takerFee, maker, taker, fillableAmount, feeRecipient)];
                                case 1:
                                    signedOrder = _a.sent();
                                    remainingFeeAmount = src_1.ZeroEx.toBaseUnitAmount(new utils_1.BigNumber(3), decimals);
                                    remainingTokenAmount = src_1.ZeroEx.toBaseUnitAmount(new utils_1.BigNumber(4), decimals);
                                    transferTokenAmount = makerFee.sub(remainingTokenAmount);
                                    zeroEx.orderStateWatcher.addOrder(signedOrder);
                                    callback = report_callback_errors_1.reportNoErrorCallbackErrors(done)(function (orderState) {
                                        var validOrderState = orderState;
                                        var orderRelevantState = validOrderState.orderRelevantState;
                                        expect(orderRelevantState.remainingFillableMakerTokenAmount).to.be.bignumber.equal(remainingFeeAmount);
                                    });
                                    zeroEx.orderStateWatcher.subscribe(callback);
                                    return [4 /*yield*/, zeroEx.token.setProxyAllowanceAsync(zrxTokenAddress, maker, remainingFeeAmount)];
                                case 2:
                                    _a.sent();
                                    return [4 /*yield*/, zeroEx.token.transferAsync(makerToken.address, maker, src_1.ZeroEx.NULL_ADDRESS, transferTokenAmount)];
                                case 3:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); })().catch(done);
                });
                it('should calculate full amount when all available and non-divisible', function (done) {
                    (function () { return __awaiter(_this, void 0, void 0, function () {
                        var takerFee, makerFee, feeRecipient, callback;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    takerFee = src_1.ZeroEx.toBaseUnitAmount(new utils_1.BigNumber(0), decimals);
                                    makerFee = src_1.ZeroEx.toBaseUnitAmount(new utils_1.BigNumber(2), decimals);
                                    feeRecipient = taker;
                                    return [4 /*yield*/, fillScenarios.createFillableSignedOrderWithFeesAsync(makerToken.address, takerToken.address, makerFee, takerFee, maker, taker, fillableAmount, feeRecipient)];
                                case 1:
                                    signedOrder = _a.sent();
                                    zeroEx.orderStateWatcher.addOrder(signedOrder);
                                    callback = report_callback_errors_1.reportNoErrorCallbackErrors(done)(function (orderState) {
                                        var validOrderState = orderState;
                                        var orderRelevantState = validOrderState.orderRelevantState;
                                        expect(orderRelevantState.remainingFillableMakerTokenAmount).to.be.bignumber.equal(fillableAmount);
                                    });
                                    zeroEx.orderStateWatcher.subscribe(callback);
                                    return [4 /*yield*/, zeroEx.token.setProxyAllowanceAsync(makerToken.address, maker, src_1.ZeroEx.toBaseUnitAmount(new utils_1.BigNumber(100), decimals))];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); })().catch(done);
                });
            });
            it('should emit orderStateInvalid when watched order cancelled', function (done) {
                (function () { return __awaiter(_this, void 0, void 0, function () {
                    var orderHash, callback;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerToken.address, takerToken.address, maker, taker, fillableAmount)];
                            case 1:
                                signedOrder = _a.sent();
                                orderHash = src_1.ZeroEx.getOrderHashHex(signedOrder);
                                zeroEx.orderStateWatcher.addOrder(signedOrder);
                                callback = report_callback_errors_1.reportNoErrorCallbackErrors(done)(function (orderState) {
                                    expect(orderState.isValid).to.be.false();
                                    var invalidOrderState = orderState;
                                    expect(invalidOrderState.orderHash).to.be.equal(orderHash);
                                    expect(invalidOrderState.error).to.be.equal(src_1.ExchangeContractErrs.OrderRemainingFillAmountZero);
                                });
                                zeroEx.orderStateWatcher.subscribe(callback);
                                return [4 /*yield*/, zeroEx.exchange.cancelOrderAsync(signedOrder, fillableAmount)];
                            case 2:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                }); })().catch(done);
            });
            it('should emit orderStateInvalid when within rounding error range', function (done) {
                (function () { return __awaiter(_this, void 0, void 0, function () {
                    var remainingFillableAmountInBaseUnits, orderHash, callback;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                remainingFillableAmountInBaseUnits = new utils_1.BigNumber(100);
                                return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerToken.address, takerToken.address, maker, taker, fillableAmount)];
                            case 1:
                                signedOrder = _a.sent();
                                orderHash = src_1.ZeroEx.getOrderHashHex(signedOrder);
                                zeroEx.orderStateWatcher.addOrder(signedOrder);
                                callback = report_callback_errors_1.reportNoErrorCallbackErrors(done)(function (orderState) {
                                    expect(orderState.isValid).to.be.false();
                                    var invalidOrderState = orderState;
                                    expect(invalidOrderState.orderHash).to.be.equal(orderHash);
                                    expect(invalidOrderState.error).to.be.equal(src_1.ExchangeContractErrs.OrderFillRoundingError);
                                });
                                zeroEx.orderStateWatcher.subscribe(callback);
                                return [4 /*yield*/, zeroEx.exchange.cancelOrderAsync(signedOrder, fillableAmount.minus(remainingFillableAmountInBaseUnits))];
                            case 2:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                }); })().catch(done);
            });
            it('should emit orderStateValid when watched order partially cancelled', function (done) {
                (function () { return __awaiter(_this, void 0, void 0, function () {
                    var cancelAmountInBaseUnits, orderHash, callback;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerToken.address, takerToken.address, maker, taker, fillableAmount)];
                            case 1:
                                signedOrder = _a.sent();
                                cancelAmountInBaseUnits = new utils_1.BigNumber(2);
                                orderHash = src_1.ZeroEx.getOrderHashHex(signedOrder);
                                zeroEx.orderStateWatcher.addOrder(signedOrder);
                                callback = report_callback_errors_1.reportNoErrorCallbackErrors(done)(function (orderState) {
                                    expect(orderState.isValid).to.be.true();
                                    var validOrderState = orderState;
                                    expect(validOrderState.orderHash).to.be.equal(orderHash);
                                    var orderRelevantState = validOrderState.orderRelevantState;
                                    expect(orderRelevantState.cancelledTakerTokenAmount).to.be.bignumber.equal(cancelAmountInBaseUnits);
                                });
                                zeroEx.orderStateWatcher.subscribe(callback);
                                return [4 /*yield*/, zeroEx.exchange.cancelOrderAsync(signedOrder, cancelAmountInBaseUnits)];
                            case 2:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                }); })().catch(done);
            });
            return [2 /*return*/];
        });
    }); });
}); // tslint:disable:max-file-line-count
//# sourceMappingURL=order_state_watcher_test.js.map