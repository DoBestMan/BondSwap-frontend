"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var dev_utils_1 = require("@0xproject/dev-utils");
var utils_1 = require("@0xproject/utils");
var chai = require("chai");
var _ = require("lodash");
require("mocha");
var Sinon = require("sinon");
var src_1 = require("../src");
var chai_setup_1 = require("./utils/chai_setup");
var constants_1 = require("./utils/constants");
var token_utils_1 = require("./utils/token_utils");
var web3_factory_1 = require("./utils/web3_factory");
var blockchainLifecycle = new dev_utils_1.BlockchainLifecycle(constants_1.constants.RPC_URL);
chai_setup_1.chaiSetup.configure();
var expect = chai.expect;
describe('ZeroEx library', function () {
    var web3 = web3_factory_1.web3Factory.create();
    var config = {
        networkId: constants_1.constants.TESTRPC_NETWORK_ID,
    };
    var zeroEx = new src_1.ZeroEx(web3.currentProvider, config);
    describe('#setProvider', function () {
        it('overrides provider in nested web3s and invalidates contractInstances', function () { return __awaiter(_this, void 0, void 0, function () {
            var newProvider, nestedWeb3WrapperProvider, exchangeWeb3WrapperProvider, tokenRegistryWeb3WrapperProvider;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: 
                    // Instantiate the contract instances with the current provider
                    return [4 /*yield*/, zeroEx.exchange._getExchangeContractAsync()];
                    case 1:
                        // Instantiate the contract instances with the current provider
                        _a.sent();
                        return [4 /*yield*/, zeroEx.tokenRegistry._getTokenRegistryContractAsync()];
                    case 2:
                        _a.sent();
                        expect(zeroEx.exchange._exchangeContractIfExists).to.not.be.undefined();
                        expect(zeroEx.tokenRegistry._tokenRegistryContractIfExists).to.not.be.undefined();
                        newProvider = web3_factory_1.web3Factory.getRpcProvider();
                        // Add property to newProvider so that we can differentiate it from old provider
                        newProvider.zeroExTestId = 1;
                        zeroEx.setProvider(newProvider, constants_1.constants.TESTRPC_NETWORK_ID);
                        // Check that contractInstances with old provider are removed after provider update
                        expect(zeroEx.exchange._exchangeContractIfExists).to.be.undefined();
                        expect(zeroEx.tokenRegistry._tokenRegistryContractIfExists).to.be.undefined();
                        nestedWeb3WrapperProvider = zeroEx._web3Wrapper.getCurrentProvider();
                        expect(nestedWeb3WrapperProvider.zeroExTestId).to.be.a('number');
                        exchangeWeb3WrapperProvider = zeroEx.exchange._web3Wrapper.getCurrentProvider();
                        expect(exchangeWeb3WrapperProvider.zeroExTestId).to.be.a('number');
                        tokenRegistryWeb3WrapperProvider = zeroEx.tokenRegistry._web3Wrapper.getCurrentProvider();
                        expect(tokenRegistryWeb3WrapperProvider.zeroExTestId).to.be.a('number');
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe('#isValidSignature', function () {
        // The Exchange smart contract `isValidSignature` method only validates orderHashes and assumes
        // the length of the data is exactly 32 bytes. Thus for these tests, we use data of this size.
        var dataHex = '0x6927e990021d23b1eb7b8789f6a6feaf98fe104bb0cf8259421b79f9a34222b0';
        var signature = {
            v: 27,
            r: '0x61a3ed31b43c8780e905a260a35faefcc527be7516aa11c0256729b5b351bc33',
            s: '0x40349190569279751135161d22529dc25add4f6069af05be04cacbda2ace2254',
        };
        var address = '0x5409ed021d9299bf6814279a6a1411a7e866a631';
        it("should return false if the data doesn't pertain to the signature & address", function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                expect(src_1.ZeroEx.isValidSignature('0x0', signature, address)).to.be.false();
                return [2 /*return*/, expect(zeroEx.exchange._isValidSignatureUsingContractCallAsync('0x0', signature, address)).to.become(false)];
            });
        }); });
        it("should return false if the address doesn't pertain to the signature & data", function () { return __awaiter(_this, void 0, void 0, function () {
            var validUnrelatedAddress;
            return __generator(this, function (_a) {
                validUnrelatedAddress = '0x8b0292b11a196601ed2ce54b665cafeca0347d42';
                expect(src_1.ZeroEx.isValidSignature(dataHex, signature, validUnrelatedAddress)).to.be.false();
                return [2 /*return*/, expect(zeroEx.exchange._isValidSignatureUsingContractCallAsync(dataHex, signature, validUnrelatedAddress)).to.become(false)];
            });
        }); });
        it("should return false if the signature doesn't pertain to the dataHex & address", function () { return __awaiter(_this, void 0, void 0, function () {
            var wrongSignature;
            return __generator(this, function (_a) {
                wrongSignature = _.assign({}, signature, { v: 28 });
                expect(src_1.ZeroEx.isValidSignature(dataHex, wrongSignature, address)).to.be.false();
                return [2 /*return*/, expect(zeroEx.exchange._isValidSignatureUsingContractCallAsync(dataHex, wrongSignature, address)).to.become(false)];
            });
        }); });
        it('should return true if the signature does pertain to the dataHex & address', function () { return __awaiter(_this, void 0, void 0, function () {
            var isValidSignatureLocal;
            return __generator(this, function (_a) {
                isValidSignatureLocal = src_1.ZeroEx.isValidSignature(dataHex, signature, address);
                expect(isValidSignatureLocal).to.be.true();
                return [2 /*return*/, expect(zeroEx.exchange._isValidSignatureUsingContractCallAsync(dataHex, signature, address)).to.become(true)];
            });
        }); });
    });
    describe('#generateSalt', function () {
        it('generates different salts', function () {
            var equal = src_1.ZeroEx.generatePseudoRandomSalt().eq(src_1.ZeroEx.generatePseudoRandomSalt());
            expect(equal).to.be.false();
        });
        it('generates salt in range [0..2^256)', function () {
            var salt = src_1.ZeroEx.generatePseudoRandomSalt();
            expect(salt.greaterThanOrEqualTo(0)).to.be.true();
            var twoPow256 = new utils_1.BigNumber(2).pow(256);
            expect(salt.lessThan(twoPow256)).to.be.true();
        });
    });
    describe('#isValidOrderHash', function () {
        it('returns false if the value is not a hex string', function () {
            var isValid = src_1.ZeroEx.isValidOrderHash('not a hex');
            expect(isValid).to.be.false();
        });
        it('returns false if the length is wrong', function () {
            var isValid = src_1.ZeroEx.isValidOrderHash('0xdeadbeef');
            expect(isValid).to.be.false();
        });
        it('returns true if order hash is correct', function () {
            var isValid = src_1.ZeroEx.isValidOrderHash('0x' + Array(65).join('0'));
            expect(isValid).to.be.true();
        });
    });
    describe('#toUnitAmount', function () {
        it('should throw if invalid baseUnit amount supplied as argument', function () {
            var invalidBaseUnitAmount = new utils_1.BigNumber(1000000000.4);
            var decimals = 6;
            expect(function () { return src_1.ZeroEx.toUnitAmount(invalidBaseUnitAmount, decimals); }).to.throw('amount should be in baseUnits (no decimals), found value: 1000000000.4');
        });
        it('Should return the expected unit amount for the decimals passed in', function () {
            var baseUnitAmount = new utils_1.BigNumber(1000000000);
            var decimals = 6;
            var unitAmount = src_1.ZeroEx.toUnitAmount(baseUnitAmount, decimals);
            var expectedUnitAmount = new utils_1.BigNumber(1000);
            expect(unitAmount).to.be.bignumber.equal(expectedUnitAmount);
        });
    });
    describe('#toBaseUnitAmount', function () {
        it('Should return the expected base unit amount for the decimals passed in', function () {
            var unitAmount = new utils_1.BigNumber(1000);
            var decimals = 6;
            var baseUnitAmount = src_1.ZeroEx.toBaseUnitAmount(unitAmount, decimals);
            var expectedUnitAmount = new utils_1.BigNumber(1000000000);
            expect(baseUnitAmount).to.be.bignumber.equal(expectedUnitAmount);
        });
        it('should throw if unitAmount has more decimals then specified as the max decimal precision', function () {
            var unitAmount = new utils_1.BigNumber(0.823091);
            var decimals = 5;
            expect(function () { return src_1.ZeroEx.toBaseUnitAmount(unitAmount, decimals); }).to.throw('Invalid unit amount: 0.823091 - Too many decimal places');
        });
    });
    describe('#getOrderHashHex', function () {
        var expectedOrderHash = '0x39da987067a3c9e5f1617694f1301326ba8c8b0498ebef5df4863bed394e3c83';
        var fakeExchangeContractAddress = '0xb69e673309512a9d726f87304c6984054f87a93b';
        var order = {
            maker: constants_1.constants.NULL_ADDRESS,
            taker: constants_1.constants.NULL_ADDRESS,
            feeRecipient: constants_1.constants.NULL_ADDRESS,
            makerTokenAddress: constants_1.constants.NULL_ADDRESS,
            takerTokenAddress: constants_1.constants.NULL_ADDRESS,
            exchangeContractAddress: fakeExchangeContractAddress,
            salt: new utils_1.BigNumber(0),
            makerFee: new utils_1.BigNumber(0),
            takerFee: new utils_1.BigNumber(0),
            makerTokenAmount: new utils_1.BigNumber(0),
            takerTokenAmount: new utils_1.BigNumber(0),
            expirationUnixTimestampSec: new utils_1.BigNumber(0),
        };
        it('calculates the order hash', function () { return __awaiter(_this, void 0, void 0, function () {
            var orderHash;
            return __generator(this, function (_a) {
                orderHash = src_1.ZeroEx.getOrderHashHex(order);
                expect(orderHash).to.be.equal(expectedOrderHash);
                return [2 /*return*/];
            });
        }); });
        it('throws a readable error message if taker format is invalid', function () { return __awaiter(_this, void 0, void 0, function () {
            var orderWithInvalidtakerFormat, expectedErrorMessage;
            return __generator(this, function (_a) {
                orderWithInvalidtakerFormat = __assign({}, order, { taker: null });
                expectedErrorMessage = 'Order taker must be of type string. If you want anyone to be able to fill an order - pass ZeroEx.NULL_ADDRESS';
                expect(function () { return src_1.ZeroEx.getOrderHashHex(orderWithInvalidtakerFormat); }).to.throw(expectedErrorMessage);
                return [2 /*return*/];
            });
        }); });
    });
    describe('#signOrderHashAsync', function () {
        var stubs = [];
        var makerAddress;
        before(function () { return __awaiter(_this, void 0, void 0, function () {
            var availableAddreses;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, zeroEx.getAvailableAddressesAsync()];
                    case 1:
                        availableAddreses = _a.sent();
                        makerAddress = availableAddreses[0];
                        return [2 /*return*/];
                }
            });
        }); });
        afterEach(function () {
            // clean up any stubs after the test has completed
            _.each(stubs, function (s) { return s.restore(); });
            stubs = [];
        });
        it('Should return the correct ECSignature', function () { return __awaiter(_this, void 0, void 0, function () {
            var orderHash, expectedECSignature, ecSignature;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        orderHash = '0x6927e990021d23b1eb7b8789f6a6feaf98fe104bb0cf8259421b79f9a34222b0';
                        expectedECSignature = {
                            v: 27,
                            r: '0x61a3ed31b43c8780e905a260a35faefcc527be7516aa11c0256729b5b351bc33',
                            s: '0x40349190569279751135161d22529dc25add4f6069af05be04cacbda2ace2254',
                        };
                        return [4 /*yield*/, zeroEx.signOrderHashAsync(orderHash, makerAddress)];
                    case 1:
                        ecSignature = _a.sent();
                        expect(ecSignature).to.deep.equal(expectedECSignature);
                        return [2 /*return*/];
                }
            });
        }); });
        it('should return the correct ECSignature for signatureHex concatenated as R + S + V', function () { return __awaiter(_this, void 0, void 0, function () {
            var orderHash, signature, expectedECSignature, ecSignature;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        orderHash = '0x34decbedc118904df65f379a175bb39ca18209d6ce41d5ed549d54e6e0a95004';
                        signature = '0x22109d11d79cb8bf96ed88625e1cd9558800c4073332a9a02857499883ee5ce3050aa3cc1f2c435e67e114cdce54b9527b4f50548342401bc5d2b77adbdacb021b';
                        expectedECSignature = {
                            v: 27,
                            r: '0x22109d11d79cb8bf96ed88625e1cd9558800c4073332a9a02857499883ee5ce3',
                            s: '0x050aa3cc1f2c435e67e114cdce54b9527b4f50548342401bc5d2b77adbdacb02',
                        };
                        stubs = [
                            Sinon.stub(zeroEx._web3Wrapper, 'signTransactionAsync').returns(Promise.resolve(signature)),
                            Sinon.stub(src_1.ZeroEx, 'isValidSignature').returns(true),
                        ];
                        return [4 /*yield*/, zeroEx.signOrderHashAsync(orderHash, makerAddress)];
                    case 1:
                        ecSignature = _a.sent();
                        expect(ecSignature).to.deep.equal(expectedECSignature);
                        return [2 /*return*/];
                }
            });
        }); });
        it('should return the correct ECSignature for signatureHex concatenated as V + R + S', function () { return __awaiter(_this, void 0, void 0, function () {
            var orderHash, signature, expectedECSignature, ecSignature;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        orderHash = '0xc793e33ffded933b76f2f48d9aa3339fc090399d5e7f5dec8d3660f5480793f7';
                        signature = '0x1bc80bedc6756722672753413efdd749b5adbd4fd552595f59c13427407ee9aee02dea66f25a608bbae457e020fb6decb763deb8b7192abab624997242da248960';
                        expectedECSignature = {
                            v: 27,
                            r: '0xc80bedc6756722672753413efdd749b5adbd4fd552595f59c13427407ee9aee0',
                            s: '0x2dea66f25a608bbae457e020fb6decb763deb8b7192abab624997242da248960',
                        };
                        stubs = [
                            Sinon.stub(zeroEx._web3Wrapper, 'signTransactionAsync').returns(Promise.resolve(signature)),
                            Sinon.stub(src_1.ZeroEx, 'isValidSignature').returns(true),
                        ];
                        return [4 /*yield*/, zeroEx.signOrderHashAsync(orderHash, makerAddress)];
                    case 1:
                        ecSignature = _a.sent();
                        expect(ecSignature).to.deep.equal(expectedECSignature);
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe('#awaitTransactionMinedAsync', function () {
        beforeEach(function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, blockchainLifecycle.startAsync()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        afterEach(function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, blockchainLifecycle.revertAsync()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        it('returns transaction receipt with decoded logs', function () { return __awaiter(_this, void 0, void 0, function () {
            var availableAddresses, coinbase, tokens, tokenUtils, zrxTokenAddress, proxyAddress, txHash, txReceiptWithDecodedLogs, log;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, zeroEx.getAvailableAddressesAsync()];
                    case 1:
                        availableAddresses = _a.sent();
                        coinbase = availableAddresses[0];
                        return [4 /*yield*/, zeroEx.tokenRegistry.getTokensAsync()];
                    case 2:
                        tokens = _a.sent();
                        tokenUtils = new token_utils_1.TokenUtils(tokens);
                        zrxTokenAddress = tokenUtils.getProtocolTokenOrThrow().address;
                        proxyAddress = zeroEx.proxy.getContractAddress();
                        return [4 /*yield*/, zeroEx.token.setUnlimitedProxyAllowanceAsync(zrxTokenAddress, coinbase)];
                    case 3:
                        txHash = _a.sent();
                        return [4 /*yield*/, zeroEx.awaitTransactionMinedAsync(txHash)];
                    case 4:
                        txReceiptWithDecodedLogs = _a.sent();
                        log = txReceiptWithDecodedLogs.logs[0];
                        expect(log.event).to.be.equal(src_1.TokenEvents.Approval);
                        expect(log.args._owner).to.be.equal(coinbase);
                        expect(log.args._spender).to.be.equal(proxyAddress);
                        expect(log.args._value).to.be.bignumber.equal(zeroEx.token.UNLIMITED_ALLOWANCE_IN_BASE_UNITS);
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe('#config', function () {
        it('allows to specify exchange contract address', function () { return __awaiter(_this, void 0, void 0, function () {
            var zeroExConfig, zeroExWithWrongExchangeAddress;
            return __generator(this, function (_a) {
                zeroExConfig = {
                    exchangeContractAddress: src_1.ZeroEx.NULL_ADDRESS,
                    networkId: constants_1.constants.TESTRPC_NETWORK_ID,
                };
                zeroExWithWrongExchangeAddress = new src_1.ZeroEx(web3.currentProvider, zeroExConfig);
                expect(zeroExWithWrongExchangeAddress.exchange.getContractAddress()).to.be.equal(src_1.ZeroEx.NULL_ADDRESS);
                return [2 /*return*/];
            });
        }); });
        it('allows to specify token registry token contract address', function () { return __awaiter(_this, void 0, void 0, function () {
            var zeroExConfig, zeroExWithWrongTokenRegistryAddress;
            return __generator(this, function (_a) {
                zeroExConfig = {
                    tokenRegistryContractAddress: src_1.ZeroEx.NULL_ADDRESS,
                    networkId: constants_1.constants.TESTRPC_NETWORK_ID,
                };
                zeroExWithWrongTokenRegistryAddress = new src_1.ZeroEx(web3.currentProvider, zeroExConfig);
                expect(zeroExWithWrongTokenRegistryAddress.tokenRegistry.getContractAddress()).to.be.equal(src_1.ZeroEx.NULL_ADDRESS);
                return [2 /*return*/];
            });
        }); });
    });
});
//# sourceMappingURL=0x.js_test.js.map