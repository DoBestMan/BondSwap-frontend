"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// some imports must use wildcard for it to work with rollupjs
const _privToAddress = __importStar(require("ethereum-private-key-to-address"));
const ethers = __importStar(require("ethers"));
const to_hex_1 = __importDefault(require("to-hex"));
const uuidlib = __importStar(require("uuidv4"));
const querystring_1 = __importDefault(require("querystring"));
const bn_js_1 = __importDefault(require("bn.js"));
const { uuid } = uuidlib;
exports.uuidv4 = uuid;
exports.privateKeyToAddress = _privToAddress;
exports.wait = (t) => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise(resolve => setTimeout(() => resolve(), t));
});
exports.toHex = (value, opts = {}) => {
    if (opts.addPrefix === undefined) {
        opts.addPrefix = true;
    }
    opts.default = 0;
    return to_hex_1.default(value, opts);
};
exports.signWithPrivateKey = (message, privateKey, providerUri) => __awaiter(void 0, void 0, void 0, function* () {
    if (!privateKey) {
        throw new Error('private key is required');
    }
    const provider = new ethers.providers.JsonRpcProvider(providerUri);
    const wallet = new ethers.Wallet(privateKey, provider);
    let data = message;
    if (message.startsWith('0x')) {
        data = ethers.utils.arrayify(message);
    }
    const signature = yield wallet.signMessage(data);
    const address = exports.privateKeyToAddress(privateKey);
    /*
    const verified = verifySignature(message, signature, address)
  
    if (!verified) {
      throw new Error('signature produced is invalid')
    }
     */
    return signature;
});
exports.debounce = (callback, time) => {
    let interval;
    return (...args) => {
        clearTimeout(interval);
        interval = setTimeout(() => {
            interval = null;
            callback(...args);
        }, time);
    };
};
exports.throttle = (fn, interval, limit = 1) => {
    const queue = new Map();
    let currentTick = 0;
    let activeCount = 0;
    const throttled = function (...args) {
        let timeout;
        return new Promise((resolve, reject) => {
            const execute = () => {
                resolve(fn.apply(this, args));
                queue.delete(timeout);
            };
            const now = Date.now();
            if ((now - currentTick) > interval) {
                activeCount = 1;
                currentTick = now;
                timeout = setTimeout(execute, currentTick - now);
            }
            else if (activeCount < limit) {
                activeCount++;
            }
            else {
                activeCount = 1;
            }
            queue.set(timeout, reject);
        });
    };
    return throttled;
};
exports.getQueryParamValue = (name) => {
    const query = window.location.search.substr(1);
    const params = querystring_1.default.parse(query);
    if (params[name]) {
        return params[name];
    }
    return null;
};
exports.removeQueryParam = (key, url = window.location.href) => {
    try {
        const u = new URL(url);
        if ('URLSearchParams' in window) {
            const searchParams = new URLSearchParams(u.search);
            searchParams.delete(key);
            u.search = searchParams.toString();
            return u.toString();
        }
    }
    catch (err) {
        // noop
    }
    return url;
};
exports.updateQueryParams = (params = {}, url = window.location.href) => {
    try {
        const u = new URL(url);
        if ('URLSearchParams' in window) {
            const searchParams = new URLSearchParams(u.search);
            for (let key in params) {
                const value = params[key];
                if (!value) {
                    continue;
                }
                searchParams.set(key, value);
            }
            u.search = searchParams.toString();
            return u.toString();
        }
    }
    catch (err) {
        // noop
    }
    return url;
};
exports.replaceWindowUrl = (newUrl) => {
    try {
        window.history.replaceState({}, document.title, newUrl);
    }
    catch (err) {
        // noop
    }
};
exports.browserInfo = () => {
    let ret;
    let tmp;
    let ua = navigator.userAgent;
    let m = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
    if (/trident/i.test(m[1])) {
        tmp = /\brv[ :]+(\d+)/g.exec(ua) || [];
        ret = 'IE ' + (tmp[1] || '');
    }
    if (m[1] === 'Chrome') {
        tmp = ua.match(/\b(OPR|Edge?)\/(\d+)/);
        if (tmp != null) {
            ret = tmp.slice(1).join(' ').replace('OPR', 'Opera').replace('Edg ', 'Edge ');
        }
    }
    m = m[2] ? [m[1], m[2]] : [navigator.appName, navigator.appVersion, '-?'];
    let v = (tmp = ua.match(/version\/(\d+)/i)) != null;
    if (v) {
        m.splice(1, 1, tmp[1]);
    }
    ret = m.join(' ');
    let p = ret.split(' ');
    return {
        browser: p[0],
        version: p[1]
    };
};
exports.exportRecoveryParam = (recoveryParam) => {
    return typeof recoveryParam === 'number'
        ? new bn_js_1.default(recoveryParam).add(new bn_js_1.default(27)).toString(16)
        : null;
};
exports.importRecoveryParam = (v) => {
    return v.trim() ? new bn_js_1.default(v, 16).sub(new bn_js_1.default(27)).toNumber() : undefined;
};
exports.serializeSignature = (sig) => {
    const v = exports.exportRecoveryParam(sig.recoveryParam);
    return '0x' + (sig.r.toString(16) + sig.s.toString(16) + v || '');
};
exports.deserializeSignature = (sig) => {
    sig = sig.replace('0x', '');
    return {
        r: new bn_js_1.default(sig.substring(0, 64), 'hex'),
        s: new bn_js_1.default(sig.substring(64, 128), 'hex'),
        recoveryParam: exports.importRecoveryParam(sig.substring(128, 130))
    };
};
