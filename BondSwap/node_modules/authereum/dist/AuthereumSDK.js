"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const penpal_1 = __importDefault(require("penpal"));
const eventemitter3_1 = __importDefault(require("eventemitter3"));
const is_buffer_1 = __importDefault(require("is-buffer"));
const version_1 = __importDefault(require("./version"));
const AuthereumProvider_1 = __importDefault(require("./AuthereumProvider"));
const StarkWareProvider_1 = __importDefault(require("./StarkWareProvider"));
const config_1 = require("./config");
const utils_1 = require("./utils");
// Serialize object for postMessage to iframe.
// Converts references to values.
const serializeMessageObj = (obj) => {
    const tx = {};
    for (let k in obj) {
        let v = obj[k];
        if (typeof v === 'object' && v.toString === 'function') {
            v = v.toString('hex');
        }
        tx[k] = v;
    }
    return tx;
};
const defaultIframeStyle = {
    width: 0,
    height: 0,
    top: 0,
    left: 0,
    zIndex: 1
};
const noop = () => {
    // noop
};
// This is a placeholder notify object stub until notifier script url is
// injected into page after iframe is loaded.
const defaultNotifier = {
    notify: (type, message) => {
        console.debug(type, message);
        return {
            dismiss: noop
        };
    }
};
const constructIframe = (input) => {
    const { id, url, isPreload, disableGoogleAnalytics } = input;
    let parentUrl = window.location.href;
    try {
        parentUrl = parent.document.URL;
    }
    catch (err) {
        // noop
    }
    const srcUrl = utils_1.updateQueryParams({
        url: parentUrl,
        isPreload,
        disableGoogleAnalytics
    }, url);
    const iframe = document.createElement('iframe');
    iframe.id = id;
    iframe.name = id.replace(/--.*/, '');
    iframe.title = id;
    iframe.src = srcUrl;
    if (['Safari', 'Firefox'].includes(utils_1.browserInfo().browser)) {
        iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin');
    }
    iframe.style.position = 'fixed';
    iframe.style.bottom = '0';
    iframe.style.right = '0';
    iframe.style.width = '0';
    iframe.style.height = '0';
    iframe.style.border = '0';
    iframe.style.background = 'transparent';
    iframe.style.zIndex = `${defaultIframeStyle.zIndex}`;
    iframe.setAttribute('frameborder', '0');
    iframe.setAttribute('scrolling', 'no');
    return iframe;
};
const onDomReady = () => {
    return new Promise((resolve) => {
        if (typeof window !== 'undefined') {
            if (document.readyState !== 'loading') {
                resolve();
            }
            else {
                document.addEventListener('DOMContentLoaded', () => resolve());
            }
        }
    });
};
class Authereum extends eventemitter3_1.default {
    constructor(config) {
        super();
        this._debug = !!utils_1.getQueryParamValue('debug');
        this._notifier = defaultNotifier;
        this._cacheReady = false;
        this._iframeReady = false;
        this._configReady = false;
        this._iframeConnecting = null;
        this._readyEmitted = false;
        this._widgetEnabled = false;
        this._iframeStyle = defaultIframeStyle;
        this._notificationIframeStyle = defaultIframeStyle;
        this._blockedPopupRedirect = true;
        this._forceRedirect = false;
        this._heartbeatStarted = false;
        this._backoffTimeout = 1;
        this._userConfig = null;
        this._asymmetricEncryptionKey = null;
        this._authereumQueryParams = {};
        this._injectedElements = [];
        this._notificationsMap = {};
        this._destroyed = false;
        this._starkProvider = null;
        this._isPreload = false;
        this._disableGoogleAnalytics = false;
        this._eventListeners = [];
        // NOTE: keep this sync
        this._init = (config) => {
            this._initConfig(config);
            this._iframeStyle = {
                width: 0,
                height: 0,
                top: 0,
                left: 0,
                zIndex: 0
            };
            this._provider = new AuthereumProvider_1.default(this);
            this._connectToChildIframe()
                .catch(() => {
                this._startHeartbeat(true);
            })
                .catch((err) => {
                console.warn('ping error:', err.message);
            });
            this._setupCache().catch(noop);
            this._cacheAuthereumQueryParams();
            this._setupSigningKey().catch(noop);
            this._setupResizeListener();
            this._setupFocusListener();
            this._setupActionKeyListener();
            this._emitReadyEvent();
        };
        // NOTE: keep this sync
        this._initConfig = (config) => {
            if (typeof config === 'string') {
                let network = config;
                this._networkName = (network || '').trim().toLowerCase();
                if (['mainnet', 'ropsten', 'rinkeby', 'kovan', 'goerli'].includes(this._networkName)) {
                    this._xsUri = config_1.defaultConfig.xsUri(this._networkName);
                }
                else if (config === 'localhost') {
                    this._xsUri = 'http://localhost:3002';
                    this._networkName = 'kovan';
                }
                else {
                    throw new Error('Unsupported network');
                }
            }
            else {
                config = config || {};
                this._networkName = config.networkName || 'mainnet';
                this._xsUri = config.xsUri || config_1.defaultConfig.xsUri(this._networkName);
                this._apiKey = config.apiKey;
            }
            if (config.redirectUri) {
                this._redirectUri = config.redirectUri;
            }
            else {
                this._redirectUri = window.location.href;
            }
            this._redirectUri = this._redirectUri || window.location.href;
        };
        // NOTE: keep this sync
        this._setConfig = (config) => {
            if (typeof this._userConfig === 'string') {
                let network = this._userConfig;
                this._networkName = (network || '').trim().toLowerCase();
                this._userConfig = {
                    networkName: this._networkName,
                    xsUri: config_1.defaultConfig.xsUri(this._networkName)
                };
            }
            const { apiKey, apiUri, rpcUri, webUri, notifierUri, networkName, networkId, disableNotifications, blockedPopupRedirect, forceRedirect } = this._userConfig || {};
            if (apiKey) {
                this._apiKey = apiKey;
            }
            // userConfig overrides regular config
            if (apiUri) {
                this._apiUri = apiUri;
            }
            else if (config.apiUri) {
                this._apiUri = config.apiUri;
            }
            // userConfig overrides regular config
            if (rpcUri) {
                this._rpcUri = rpcUri;
            }
            else if (config.rpcUri) {
                this._rpcUri = config.rpcUri;
            }
            // userConfig overrides regular config
            if (webUri) {
                this._webUri = webUri;
            }
            else if (config.webUri) {
                this._webUri = config.webUri;
            }
            // userConfig overrides regular config
            if (notifierUri) {
                this._notifierUri = notifierUri;
            }
            else if (config.notifierUri) {
                this._notifierUri = config.notifierUri;
            }
            // userConfig overrides regular config
            if (networkName) {
                this._networkName = networkName;
            }
            else if (config.networkName) {
                this._networkName = config.networkName;
            }
            // userConfig overrides regular config
            if (networkId) {
                this._networkId = networkId;
            }
            else if (config.networkId) {
                this._networkId = config.networkId;
            }
            // userConfig overrides regular config
            if (typeof disableNotifications === 'boolean') {
                this._disableNotifications = disableNotifications;
            }
            else if (typeof config.disableNotifications === 'boolean') {
                this._disableNotifications = config.disableNotifications;
            }
            // userConfig overrides regular config
            if (typeof blockedPopupRedirect === 'boolean') {
                this._blockedPopupRedirect = blockedPopupRedirect;
            }
            else if (typeof config.blockedPopupRedirect === 'boolean') {
                this._blockedPopupRedirect = config.blockedPopupRedirect;
            }
            // userConfig overrides regular config
            if (typeof forceRedirect === 'boolean') {
                this._forceRedirect = forceRedirect;
            }
            else if (typeof config.forceRedirect === 'boolean') {
                this._forceRedirect = config.forceRedirect;
            }
        };
        this._setupCache = () => __awaiter(this, void 0, void 0, function* () {
            yield Promise.all([
                this._cacheLoginKeyAddress(),
                this._cacheIsAuthenticated(),
                this._cacheAccountAddress()
            ]);
            this._cacheReady = true;
        });
        this._handleWindowFocus = () => {
            if (this._destroyed) {
                return;
            }
            if (!this._bodyContainsIframe()) {
                return;
            }
            return this._postMessageToChild({
                method: 'onWindowFocus'
            });
        };
        this._resetCache = () => __awaiter(this, void 0, void 0, function* () {
            return this._setupCache();
        });
        this._injectScript = (sourceUrl, id = '') => __awaiter(this, void 0, void 0, function* () {
            yield this._tilDomReady();
            return new Promise((resolve, reject) => {
                if (!sourceUrl) {
                    throw new Error('sourceUrl is required');
                }
                if (document.getElementById(id)) {
                    resolve();
                    return;
                }
                const script = document.createElement('script');
                script.id = id;
                script.type = 'text/javascript';
                script.async = true;
                script.onload = () => {
                    resolve();
                };
                script.onerror = (err) => {
                    reject(err);
                };
                script.src = sourceUrl;
                this._injectedElements.push(script);
                document.getElementsByTagName('head')[0].appendChild(script);
            });
        });
        this._setupResizeListener = () => __awaiter(this, void 0, void 0, function* () {
            this.addEventListener('resize', this._handleResizeThrottled, false);
            this.addEventListener('resize', this._handleResizeDebounced, false);
        });
        this._handleActionKeyPress = (event) => {
            if (this._destroyed) {
                return;
            }
            if (!this._bodyContainsIframe()) {
                return;
            }
            let keyName = '';
            if (event.key === 'Escape' || event.key === 'Esc' || event.keyCode === 27) {
                keyName = 'escape';
            }
            else if (event.key === 'Enter' || event.keyCode === 13) {
                keyName = 'enter';
            }
            else if (event.key === 'ArrowLeft' || event.keyCode === 37) {
                keyName = 'left';
            }
            else if (event.key === 'ArrowUp' || event.keyCode === 38) {
                keyName = 'up';
            }
            else if (event.key === 'ArrowRight' || event.keyCode === 39) {
                keyName = 'right';
            }
            else if (event.key === 'ArrowDown' || event.keyCode === 40) {
                keyName = 'down';
            }
            if (keyName) {
                return this._postMessageToChild({
                    method: 'actionKeyPress',
                    params: keyName
                });
            }
        };
        this._handleResize = (event) => __awaiter(this, void 0, void 0, function* () {
            if (this._destroyed) {
                return;
            }
            if (!this._bodyContainsIframe()) {
                return;
            }
            const size = yield this._getWindowSize();
            return this._postMessageToChild({
                method: 'onResize',
                params: size
            });
        });
        this._handleResizeThrottled = utils_1.throttle((event) => {
            return this._handleResize(event);
        }, 10);
        this._handleResizeDebounced = utils_1.debounce((event) => {
            return this._handleResize(event);
        }, 10);
        this._cacheLoginKeyAddress = () => __awaiter(this, void 0, void 0, function* () {
            const loginKey = yield this._postMessageToChild({
                method: 'getOrCreateLoginKey'
            });
            this._cachedLoginKeyAddress = loginKey.publicAddress;
        });
        this._cacheAccountAddress = () => __awaiter(this, void 0, void 0, function* () {
            const accountAddress = yield this._postMessageToChild({
                method: 'getAccountAddress'
            });
            this._cachedAccountAddress = accountAddress;
        });
        this._cacheIsAuthenticated = () => __awaiter(this, void 0, void 0, function* () {
            const isAuthenticated = yield this._postMessageToChild({
                method: 'isAuthenticated'
            });
            this._cachedIsAuthenticated = isAuthenticated;
        });
        // NOTE: to prevent pop-ups from being blocked, there must be no awaits from
        // click to window.open, meaning value lookups must be cached before the
        // login method is called.
        this.login = utils_1.throttle(() => __awaiter(this, void 0, void 0, function* () {
            const isIframeReady = this._iframeReady && this._cacheReady;
            const isConfigReady = this._configReady;
            // these are false when dapp calls login immediately on page load
            // so we're forced to wait here.
            if (!(isIframeReady && isConfigReady)) {
                yield this._tilConfigReady();
                yield this._tilReady();
            }
            if (!this._cachedIsAuthenticated) {
                // NOTE: if not logged in to dapp, then proceed to login
                yield this._signLoginKeyRequest(this._cachedLoginKeyAddress);
                return this.getAuthenticatedAccount();
            }
            else {
                // only show one already logged in notification at a time
                if (!this._notificationsMap['loggedIn']) {
                    this._postMessageToChild({
                        method: 'notification',
                        params: {
                            type: 'success',
                            message: 'You are logged into Authereum',
                            timeout: 5e3
                        }
                    })
                        .catch(noop);
                    this._notificationsMap['loggedIn'] = true;
                    setTimeout(() => {
                        this._notificationsMap['loggedIn'] = null;
                    }, 5e3);
                }
            }
            // await first
            const account = yield this.getAuthenticatedAccount();
            return account;
        }), 250);
        this.authenticate = () => __awaiter(this, void 0, void 0, function* () {
            console.warn('Deprecation notice: `authereum.authenticate()` is deprecated. Use `authereum.login()` instead.');
            return this.login();
        });
        this.isAuthenticated = () => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'isAuthenticated'
            }));
        });
        this.logout = () => __awaiter(this, void 0, void 0, function* () {
            const res = yield this._postMessageToChild({
                method: 'logout'
            });
            yield this._resetCache();
            this.emit('logout', {});
            return res;
        });
        this.getAuthenticatedAccount = () => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'getAuthenticatedAccount'
            }));
        });
        this.getDappKey = () => {
            return this._handleError(this._postMessageToChild({
                method: 'getLoginKey'
            }));
        };
        this.getLoginKey = () => {
            console.warn('Deprecation notice: `authereum.getLoginKey()` is deprecated. Use `authereum.getDappKey()` instead.');
            return this.getDappKey();
        };
        this.signMessage = utils_1.throttle((message, options = {}) => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'signMessage',
                params: [message, options]
            }));
        }), 250);
        this.signPersonalMessage = utils_1.throttle((message) => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'signMessage',
                params: [message, { personal: true }]
            }));
        }), 250);
        this.signWithDappKey = utils_1.throttle((message) => __awaiter(this, void 0, void 0, function* () {
            console.warn('Deprecation notice: `authereum.signWithDappKey()` is deprecated. Use `authereum.signMess()` instead.');
            return this.signMessage(message);
        }), 250);
        this.signWithLoginKey = utils_1.throttle((message) => __awaiter(this, void 0, void 0, function* () {
            console.warn('Deprecation notice: `authereum.signWithLoginKey()` is deprecated. Use `authereum.signWithDappKey()` instead.');
            return this.signWithDappKey(message);
        }), 250);
        this.signTypedMessage = utils_1.throttle((message, options = {}) => __awaiter(this, void 0, void 0, function* () {
            console.warn('Deprecation notice: `authereum.signTypedMessage()` is deprecated. Use `authereum.signMessage()` instead.');
            return this.signMessage(message, options);
        }), 250);
        this.signTypedMessageWithDappKey = utils_1.throttle((message) => __awaiter(this, void 0, void 0, function* () {
            console.warn('Deprecation notice: `authereum.signTypedMessageWithDappKey()` is deprecated. Use `authereum.signMessage()` instead.');
            return this.signTypedMessage(message);
        }), 250);
        this.signMessageWithAdminKey = utils_1.throttle((message) => __awaiter(this, void 0, void 0, function* () {
            console.warn('Deprecation notice: `authereum.signMessageWithAdminKey()` is deprecated. Use `authereum.signMessageWithSigningKey()` instead.');
            return null;
        }), 250);
        this.signMessageWithSigningKey = utils_1.throttle((message, options = {}) => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'signMessageWithSigningKey',
                params: [message, options]
            }));
        }), 250);
        this.getSigningKeyAddress = (message) => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'getSigningKeyAddress'
            }));
        });
        this.getLoginKeyAuthSignature = () => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'getLoginKeyAuthSignature'
            }));
        });
        this.getLoginKeyRestrictionsData = () => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'getLoginKeyRestrictionsData'
            }));
        });
        this.getSigningKeyAuthSignature = () => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'getSigningKeyAuthSignature'
            }));
        });
        this.getAccountAddress = () => __awaiter(this, void 0, void 0, function* () {
            // required so it waits for login key to be set
            yield this._tilReady();
            return this._handleError(this._postMessageToChild({
                method: 'getAccountAddress'
            }));
        });
        this.getBalance = () => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'getBalance'
            }));
        });
        this.getRpcUri = () => __awaiter(this, void 0, void 0, function* () {
            yield this._tilConfigReady();
            return this._rpcUri;
        });
        this.getNetworkId = () => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'getNetworkId'
            }));
        });
        this.getNetworkName = () => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'getNetworkName'
            }));
        });
        this.getCachedNetworkName = () => {
            return this._networkName;
        };
        this.getProvider = () => {
            return this._provider;
        };
        this.getStarkProvider = () => {
            return this._starkProvider;
        };
        this._handleError = (promise) => __awaiter(this, void 0, void 0, function* () {
            return promise
                .catch((err) => {
                // NOTE: emit errors but don't throw notification here.
                this.emit('error', err);
                // NOTE: rethrow error to let dapps handle error
                throw err;
            });
        });
        this.signTransaction = utils_1.throttle((tx) => __awaiter(this, void 0, void 0, function* () {
            yield this._tilReady();
            return this._handleError(this._postMessageToChild({
                method: 'signTransaction',
                params: serializeMessageObj(tx)
            }));
        }), 250);
        this.signTransactionWithLoginKey = utils_1.throttle((tx) => __awaiter(this, void 0, void 0, function* () {
            console.warn('Deprecation notice: `authereum.signTransactionWithLoginKey()` is deprecated. Use `authereum.signTransaction()` instead.');
            return this.signTransaction(tx);
        }), 250);
        this.sendTransaction = utils_1.throttle((userTransaction) => __awaiter(this, void 0, void 0, function* () {
            yield this._tilReady();
            return this._handleError(this._postMessageToChild({
                method: 'sendTransaction',
                params: serializeMessageObj(userTransaction)
            }));
        }), 250);
        this.sendTransactionBatch = utils_1.throttle((userTransactions) => __awaiter(this, void 0, void 0, function* () {
            yield this._tilReady();
            return this._handleError(this._postMessageToChild({
                method: 'sendTransactionBatch',
                params: userTransactions.map(serializeMessageObj)
            }));
        }), 250);
        this.estimateGasBatch = utils_1.throttle((userTransactions) => __awaiter(this, void 0, void 0, function* () {
            yield this._tilReady();
            return this._handleError(this._postMessageToChild({
                method: 'estimateGasBatch',
                params: userTransactions.map(serializeMessageObj)
            }));
        }), 250);
        this.isReady = () => {
            return this._iframeReady && this._cacheReady;
        };
        this.updateConfig = (config) => {
            this._userConfig = config;
            this._setConfig(config);
        };
        this.getConfig = () => {
            return {
                apiUri: this._apiUri,
                rpcUri: this._rpcUri,
                webUri: this._webUri,
                xsUri: this._xsUri,
                networkName: this._networkName,
                networkId: this._networkId,
                disableNotifications: this._disableNotifications
            };
        };
        this.showWidget = (enabled = true) => __awaiter(this, void 0, void 0, function* () {
            if (!enabled) {
                this._widgetEnabled = false;
                return this._postMessageToChild({
                    method: 'hideWidget'
                });
            }
            this._widgetEnabled = true;
            return this._postMessageToChild({
                method: 'showWidget'
            });
        });
        this.hideWidget = () => __awaiter(this, void 0, void 0, function* () {
            this._widgetEnabled = false;
            return this._postMessageToChild({
                method: 'hideWidget'
            });
        });
        this.widgetEnabled = () => {
            return this._widgetEnabled;
        };
        this.addFunds = (opts) => {
            return this._postMessageToChild({
                method: 'addFunds',
                params: opts
            });
        };
        this._openUrl = (opts = {}) => {
            const { url, newWindow } = opts;
            if (newWindow) {
                window.open(url, '_blank');
            }
            else {
                window.location.href = url;
            }
        };
        this._tilIframeReady = () => __awaiter(this, void 0, void 0, function* () {
            if (!this._iframeReady) {
                yield utils_1.wait(100);
                return this._tilIframeReady();
            }
            yield utils_1.wait(100);
            return true;
        });
        this._tilConfigReady = () => __awaiter(this, void 0, void 0, function* () {
            if (!this._configReady) {
                yield utils_1.wait(100);
                return this._tilConfigReady();
            }
            yield utils_1.wait(100);
            return true;
        });
        this._tilReady = () => __awaiter(this, void 0, void 0, function* () {
            if (!this.isReady()) {
                yield utils_1.wait(100);
                return this._tilReady();
            }
            yield utils_1.wait(100);
            return true;
        });
        this._emitReadyEvent = () => __awaiter(this, void 0, void 0, function* () {
            yield this._tilReady();
            if (this._readyEmitted)
                return;
            this._readyEmitted = true;
            this.emit('ready', {});
        });
        this._connectToChildIframe = () => __awaiter(this, void 0, void 0, function* () {
            if (this._iframeConnecting) {
                return this._iframeConnecting;
            }
            this._iframeReady = false;
            this._iframeConnecting = true;
            const iframe = yield this._getOrCreateMainIframe();
            this._iframeConnection = penpal_1.default.connectToChild({
                iframe,
                timeout: 60e3,
                methods: {
                    // NOTE: the postMessage penpal method should be the only method that
                    // exists.
                    postMessage: (data) => {
                        return this._handlePostMessage(data);
                    }
                }
            });
            this._iframeConnecting = new Promise((resolve, reject) => {
                let timedout = false;
                const timer = setTimeout(() => {
                    if (!this._iframeReady) {
                        timedout = true;
                        this._iframeConnecting = null;
                        reject(new Error('timedout'));
                    }
                }, 6e3); // needs to be long enough for x-site to be fully loaded
                this._iframeConnection.promise.then((child) => {
                    clearTimeout(timer);
                    if (timedout) {
                        return;
                    }
                    this._iframeReady = true;
                    this._childIframeConnection = child;
                    this._startHeartbeat();
                    this._iframeConnecting = null;
                    resolve();
                })
                    .catch((err) => {
                    clearTimeout(timer);
                    if (timedout) {
                        return;
                    }
                    reject(err);
                });
            });
            return this._iframeConnecting;
        });
        this._startHeartbeat = (reconnect = false) => {
            if (!this._heartbeatStarted) {
                this._heartbeat(reconnect);
                this._heartbeatStarted = true;
            }
        };
        this._heartbeat = (reconnect = false) => __awaiter(this, void 0, void 0, function* () {
            if (this._destroyed) {
                return;
            }
            yield utils_1.wait(2e3);
            try {
                if (reconnect) {
                    yield this._connectToChildIframe();
                    this._backoffTimeout = 1;
                    return this._heartbeat();
                }
                yield this._ping();
            }
            catch (err) {
                // reconnect on destroyed connection error or ping timeout error
                if (/destroy|timedout/gi.test(err.message)) {
                    yield utils_1.wait(this._backoffTimeout * 1e3);
                    // exponential backoff
                    this._backoffTimeout = this._backoffTimeout << 1;
                    return this._heartbeat(true);
                }
            }
            return this._heartbeat();
        });
        this._ping = () => __awaiter(this, void 0, void 0, function* () {
            if (this._destroyed) {
                console.warn('Authereum instance destroyed. Message not posted to child.');
                return;
            }
            return new Promise((resolve, reject) => {
                let timedout = false;
                const timer = setTimeout(() => {
                    timedout = true;
                }, 5e3);
                this._postMessageToChild({
                    method: 'ping'
                }).then((pong) => {
                    clearTimeout(timer);
                    if (timedout) {
                        reject(new Error('timedout'));
                        return;
                    }
                    if (pong !== 'pong') {
                        reject(new Error('Invalid response'));
                        return;
                    }
                    resolve(pong);
                })
                    .catch(err => {
                    reject(err);
                });
            });
        });
        this._constructIframe = (input) => {
            const iframe = constructIframe(Object.assign(Object.assign({}, input), { isPreload: this._isPreload, disableGoogleAnalytics: this._disableGoogleAnalytics }));
            if (this._debug) {
                iframe.style.outline = '1px solid red';
            }
            this._injectedElements.push(iframe);
            return iframe;
        };
        this._getConfigFromChild = () => __awaiter(this, void 0, void 0, function* () {
            return this._postMessageToChild({
                method: 'getConfig'
            });
        });
        this._postVersionToChild = () => __awaiter(this, void 0, void 0, function* () {
            return this._postMessageToChild({
                method: 'version',
                params: this.version()
            });
        });
        this._postConfigToChild = () => __awaiter(this, void 0, void 0, function* () {
            return this._postMessageToChild({
                method: 'config',
                params: {
                    apiKey: this._apiKey,
                    disableNotifications: this._disableNotifications
                }
            });
        });
        this._loadAsymmetricEncryptionKeyFromChild = () => __awaiter(this, void 0, void 0, function* () {
            this._asymmetricEncryptionKey = yield this._postMessageToChild({
                method: 'getAsymmetricEncryptionKey'
            });
        });
        this._postMessageToChild = (payload) => __awaiter(this, void 0, void 0, function* () {
            yield this._tilIframeReady();
            if (this._destroyed) {
                throw new Error('Authereum instance destroyed.');
            }
            if (!this._bodyContainsIframe()) {
                this._destroyed = true;
                this._teardownEventListeners();
                // ignore destroy call to already destroyed iframe
                if (payload.method === 'destroy') {
                    return;
                }
                throw new Error('Authereum instance or iframe destroyed.');
            }
            return this._handleError(this._childIframeConnection.postMessage(payload));
        });
        this._handleChildLogoutEvent = () => __awaiter(this, void 0, void 0, function* () {
            yield this._resetCache();
            this.emit('logout', {});
        });
        this._handleChildDappKeyExpired = (loginKeyAddress) => __awaiter(this, void 0, void 0, function* () {
            if (loginKeyAddress === this._cachedLoginKeyAddress) {
                yield this._resetCache();
                this.emit('dappKeyExpired', loginKeyAddress);
                this.emit('logout');
            }
        });
        this._handlePostMessage = (data) => {
            try {
                const { method, params } = data;
                switch (method) {
                    case 'onError':
                        const err = params;
                        this.emit('error', err);
                        this._notifier.notify({
                            type: 'error',
                            message: err.message
                        });
                        return;
                    case 'onLogout':
                        return this._handleChildLogoutEvent();
                    case 'onDappKeyExpired':
                        return this._handleChildDappKeyExpired(params);
                    case 'login':
                        return this.login();
                    case 'setWidgetPosition':
                        // const position = params
                        // const { x, y } = position
                        // this.iframeStyle.left = x
                        // this.iframeStyle.top = y
                        // this._refreshWidget()
                        return;
                    case 'setWidgetSize': {
                        const size = params;
                        const { width, height } = size;
                        this._iframeStyle.width = width;
                        this._iframeStyle.height = height;
                        return this._refreshWidget();
                    }
                    case 'setWidgetStyle': {
                        const style = params;
                        for (let key in style) {
                            this._iframeStyle[key] = style[key];
                        }
                        return this._refreshWidget();
                    }
                    case 'setNotificationWidgetSize': {
                        const size = params;
                        const { width, height } = size;
                        this._notificationIframeStyle.width = width;
                        this._notificationIframeStyle.height = height;
                        return this._refreshNotificationWidget();
                    }
                    case 'setNotificationWidgetStyle': {
                        const style = params;
                        for (let key in style) {
                            this._notificationIframeStyle[key] = style[key];
                        }
                        return this._refreshNotificationWidget();
                    }
                    case 'getWindowSize':
                        return this._getWindowSize();
                    case 'hideWidget':
                        return this.hideWidget();
                    case 'log':
                        return this._handlePostMessageLog(params);
                    case 'openUrl':
                        return this._openUrl(params);
                    default:
                        break;
                }
            }
            catch (err) {
                // noop
            }
        };
        this._handlePostMessageLog = (data) => {
            if (this._isPreload) {
                return;
            }
            let { type, message } = data;
            if (!type) {
                type = 'log';
            }
            console[type](message);
        };
        this._getWindowSize = () => {
            return {
                width: this._getWindowWidth(),
                height: this._getWindowHeight()
            };
        };
        this._getWindowWidth = () => {
            return window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
        };
        this._getWindowHeight = () => {
            return window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
        };
        // public _setIframePositionTop = (y: number) => {
        // if (!this._iframe) return
        // this._iframe.style.top = `${y}px`
        // }
        this._setIframePositionLeft = (x) => {
            if (!this._iframe)
                return;
            this._iframe.style.left = `${x}px`;
        };
        this._setIframeWidth = (width) => {
            if (!this._iframe)
                return;
            this._iframe.style.width = `${width}px`;
        };
        this._setIframeHeight = (height) => {
            if (!this._iframe)
                return;
            this._iframe.style.height = `${height}px`;
        };
        this._refreshWidget = () => {
            const { top, left, width, height, zIndex } = this._iframeStyle;
            if (this._isPreload)
                return;
            if (!this._iframe)
                return;
            // this._setIframePositionTop(top)
            // this._setIframePositionLeft(left)
            this._setIframeWidth(width);
            this._setIframeHeight(height);
            this._iframe.style.zIndex = `${zIndex || 0}`;
        };
        this._refreshNotificationWidget = () => {
            const { top, left, width, height, zIndex } = this._notificationIframeStyle;
            if (this._isPreload)
                return;
            this._notificationIframe.style.width = `${width}px`;
            this._notificationIframe.style.height = `${height}px`;
            this._notificationIframe.style.zIndex = `${zIndex || 0}`;
        };
        this._loginKeyExists = () => __awaiter(this, void 0, void 0, function* () {
            return !!(yield this.getLoginKey());
        });
        this._accountAddressExists = () => __awaiter(this, void 0, void 0, function* () {
            return !!(yield this.getAccountAddress());
        });
        this._getAccountAdminKeyNonce = () => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'getAccountAuthKeyNonce'
            }));
        });
        this._getAccountAuthKeyNonce = () => __awaiter(this, void 0, void 0, function* () {
            console.warn('Deprecation notice: `authereum._getAccountAuthKeyNonce()` is deprecated. Use `authereum._getAccountAdminKeyNonce()` instead.');
            return this._getAccountAdminKeyNonce();
        });
        this._executeLoginKeyMetaTx = (tx) => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'executeLoginKeyMetaTx',
                params: serializeMessageObj(tx)
            }));
        });
        this._loadLoginKey = (loginKey) => __awaiter(this, void 0, void 0, function* () {
            yield this._tilReady();
            return this._handleError(this._postMessageToChild({
                method: 'loadLoginKey',
                params: loginKey
            }));
        });
        this._getOrCreateLoginKey = () => __awaiter(this, void 0, void 0, function* () {
            yield this._tilReady();
            return this._handleError(this._postMessageToChild({
                method: 'getOrCreateLoginKey'
            }));
        });
        this._getAuthenticateUri = (loginKeyAddress) => {
            const encryptionKey = this._asymmetricEncryptionKey;
            const date = new Date();
            date.setDate(date.getDate() + 30); // expire in 30 days
            const expiresAt = (date.getTime() / 1e3) | 0;
            // NOTE: slk = sign login key
            return this._webUri + '/?slk=' + encodeURIComponent(JSON.stringify({
                loginKey: {
                    publicAddress: loginKeyAddress,
                    expiresAt
                },
                encryptionKey
            })) + '&redirect_uri=' + this._redirectUri;
        };
        this._getSignWithAdminKeyUri = (message) => {
            if (is_buffer_1.default(message)) {
                message = `0x${message.toString('hex')}`;
            }
            // NOTE: sm = sign message
            return this._webUri + '/?sm=' + encodeURIComponent(JSON.stringify({
                message
            })) + '&redirect_uri=' + this._redirectUri;
        };
        this._openPopupOrRedirect = (url) => __awaiter(this, void 0, void 0, function* () {
            this.emit('openPopup', {});
            if (this._forceRedirect) {
                window.location.href = url;
                return;
            }
            let child = this._getAuthereumPopupWindow(url);
            let isBlocked = this._isAuthereumPopupBlocked(child);
            if (isBlocked && !this._blockedPopupRedirect) {
                const err = new Error('Disable popup blocker and try again');
                this._notifier.notify({
                    type: 'error',
                    message: err.message,
                    timeout: 5000
                });
                throw err;
            }
            else if (isBlocked) {
                this.emit('popupBlocked');
                const shouldShowPopupOrRedirect = yield this._showConfirmPopupOrRedirectModal();
                if (!shouldShowPopupOrRedirect) {
                    const errMessage = 'Popup or redirect rejected';
                    this.emit('error', errMessage);
                    throw new Error(errMessage);
                }
                // Try to bring up a user-initiated popup. If this fails
                // fallback to a redirect
                child = this._getAuthereumPopupWindow(url);
                isBlocked = this._isAuthereumPopupBlocked(child);
                if (isBlocked) {
                    window.location.href = url;
                    return;
                }
            }
            child.focus();
            return new Promise((resolve, reject) => {
                const interval = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                    if (child.closed) {
                        cleanUp();
                        const err = new Error('Window closed');
                        this.emit('error', err);
                        this.emit('closePopup', {});
                        reject(err);
                    }
                }), 250);
                const timeout = setTimeout(() => {
                    cleanUp();
                    child.close();
                    doneWithError(new Error('Timedout'));
                }, 10 * 60 * 1000);
                const cleanUp = () => {
                    clearInterval(interval);
                    clearTimeout(timeout);
                    this.emit('closePopup', {});
                };
                const doneWithError = (err) => {
                    cleanUp();
                    this.emit('error', err);
                    reject(err);
                };
                const done = (result = {}) => {
                    cleanUp();
                    resolve(result);
                };
                const handleParentMessageEvent = (event) => __awaiter(this, void 0, void 0, function* () {
                    if (event.origin.includes(this._webUri)) {
                        // this event tells parent to close child popup
                        if (event.data.close) {
                            child.close();
                            done();
                        }
                        if (event.data.login) {
                            done({ success: true });
                            this.emit('login', {});
                            this._cachedIsAuthenticated = true;
                            if (event.data.encryptedSigningKey) {
                                yield this._loadSigningKey(event.data.encryptedSigningKey);
                            }
                            this._logAnalyticsEvent({
                                eventType: 'logged_in_dapp',
                                properties: {
                                    dapp_url: window.location.href
                                }
                            });
                            if (this._redirectUri !== window.location.href) {
                                window.location.href = this._redirectUri;
                            }
                        }
                        if (event.data.result) {
                            done(event.data.result);
                            if (this._redirectUri !== window.location.href) {
                                window.location.href = this._redirectUri;
                            }
                        }
                        if (event.data.error) {
                            doneWithError(new Error(event.data.error));
                            if (this._redirectUri !== window.location.href) {
                                window.location.href = this._redirectUri;
                            }
                        }
                    }
                });
                this.addEventListener('message', handleParentMessageEvent, false);
            });
        });
        this.addEventListener = (type, listener, useCapture = false) => {
            window.addEventListener(type, listener, useCapture);
            this._eventListeners.push({ type, listener, useCapture });
        };
        this._showConfirmPopupOrRedirectModal = () => {
            return this._handleError(this._postMessageToChild({
                method: 'showConfirmPopupOrRedirectModal'
            }));
        };
        this._signLoginKeyRequest = (publicAddress) => __awaiter(this, void 0, void 0, function* () {
            const url = this._getAuthenticateUri(publicAddress);
            return this._openPopupOrRedirect(url);
        });
        this._tilDomReady = () => __awaiter(this, void 0, void 0, function* () {
            return onDomReady();
        });
        // keep both static and normal version methods
        this.version = () => {
            return version_1.default;
        };
        this.isAuthenticatedSync = () => {
            return this._cachedIsAuthenticated;
        };
        this.getTransactionReceipt = (txHash) => {
            return this._handleError(this._postMessageToChild({
                method: 'getTransactionReceipt',
                params: txHash
            }));
        };
        this.waitForTransactionReceipt = (txHash) => {
            return this._handleError(this._postMessageToChild({
                method: 'waitForTransactionReceipt',
                params: txHash
            }));
        };
        this.hasRecoveryEnabled = () => {
            return this._handleError(this._postMessageToChild({
                method: 'hasRecoveryEnabled'
            }));
        };
        this.isContractDeployed = (accountAddress) => {
            return this._handleError(this._postMessageToChild({
                method: 'isContractDeployed',
                params: accountAddress
            }));
        };
        this._loadSigningKey = (signingKey) => __awaiter(this, void 0, void 0, function* () {
            if (this._destroyed) {
                console.warn('Authereum instance destroyed. Message not posted to child.');
                return;
            }
            return this._postMessageToChild({
                method: 'loadSigningKey',
                params: signingKey
            });
        });
        this._logAnalyticsEvent = (input) => __awaiter(this, void 0, void 0, function* () {
            if (this._destroyed) {
                console.warn('Authereum instance destroyed. Message not posted to child.');
                return;
            }
            return this._postMessageToChild({
                method: 'logAnalyticsEvent',
                params: input
            });
        });
        this._setupSigningKey = () => __awaiter(this, void 0, void 0, function* () {
            yield this._tilReady();
            const encryptedSigningKey = this._authereumQueryParams['encryptedSigningKey'];
            if (encryptedSigningKey) {
                const success = yield this._loadSigningKey(encryptedSigningKey);
                if (success) {
                    try {
                        localStorage.removeItem('_authereum');
                    }
                    catch (err) {
                        // noop
                    }
                }
            }
        });
        this._cacheAuthereumQueryParams = () => __awaiter(this, void 0, void 0, function* () {
            try {
                const param = utils_1.getQueryParamValue('_authereum');
                if (param) {
                    this._authereumQueryParams = JSON.parse(param);
                    try {
                        localStorage.setItem('_authereum', btoa(JSON.stringify(this._authereumQueryParams)));
                    }
                    catch (err) {
                        // noop
                    }
                    const newUrl = utils_1.removeQueryParam('_authereum');
                    utils_1.replaceWindowUrl(newUrl);
                }
                else {
                    try {
                        // load from local storage cache if exists.
                        // this local storage is cleared after connection.
                        let cached = localStorage.getItem('_authereum');
                        if (cached) {
                            this._authereumQueryParams = JSON.parse(atob(cached));
                        }
                    }
                    catch (err) {
                        // noop
                    }
                }
            }
            catch (err) {
                // noop
            }
        });
        this.destroy = () => __awaiter(this, void 0, void 0, function* () {
            if (this._destroyed) {
                console.warn('Authereum instance already destroyed.');
                return true;
            }
            try {
                if (this._iframeReady && this._bodyContainsIframe()) {
                    yield this._postMessageToChild({
                        method: 'destroy'
                    });
                }
            }
            catch (err) {
                console.warn(err);
            }
            for (let i = 0; i < this._injectedElements.length; i++) {
                const element = this._injectedElements[i];
                try {
                    element.remove();
                }
                catch (err) {
                    console.error(err);
                }
            }
            /*
            const elements = document.querySelectorAll('[id*="authereum"]')
            for (let i = 0; i < elements.length; i++) {
              const element = elements[i]
              try {
                element.remove()
              } catch (err) {
                console.error(err)
              }
            }
            */
            this._iframeReady = false;
            this._destroyed = true;
            console.warn('Authereum instance destroyed.');
            this._teardownEventListeners();
            this.emit('destroy', {});
            return true;
        });
        this.isDestroyed = () => {
            return this._destroyed;
        };
        this.getAddressQrCodeDataUri = (address) => __awaiter(this, void 0, void 0, function* () {
            return this._postMessageToChild({
                method: 'getAddressQrCodeDataUri',
                params: {
                    address
                }
            });
        });
        this._loadNotificationsIframe = (url) => __awaiter(this, void 0, void 0, function* () {
            const id = 'authereum__x-notification-iframe';
            let el = document.getElementById(id);
            if (el && el.src === url) {
                this._notificationIframe = el;
            }
            else {
                if (el) {
                    el.remove();
                }
                this._notificationIframe = this._constructIframe({ id, url });
                this._notificationIframe.style.top = '0';
                this._notificationIframe.style.right = '0';
                yield this._tilDomReady();
                el = document.getElementById(id);
                if (el) {
                    el.remove();
                }
                document.body.appendChild(this._notificationIframe);
            }
        });
        this._setDebug = (enabled) => __awaiter(this, void 0, void 0, function* () {
            this._debug = enabled;
            if (this._debug) {
                this._iframe.style.outline = '1px solid red';
                this._notificationIframe.style.outline = '1px solid red';
            }
            else {
                this._iframe.style.outline = '0';
                this._notificationIframe.style.outline = '0';
            }
        });
        this._userConfig = config;
        if (config instanceof Object) {
            this._isPreload = !!config.isPreload;
            this._disableGoogleAnalytics = !!config.disableGoogleAnalytics;
        }
        const merged = this._checkCachedInstance(config);
        if (merged) {
            return merged;
        }
        this._init(config);
        this._starkProvider = new StarkWareProvider_1.default(this);
        if (window._authereumInstances) {
            window._authereumInstances.push(this);
        }
    }
    _checkCachedInstance(config) {
        let cachedInstance = null;
        if (Array.isArray(window._authereumInstances)) {
            if (window._authereumInstances.length) {
                cachedInstance = window._authereumInstances.pop();
            }
        }
        // checks if preloaded cached iframe matches the same network as user created
        // instance, and if so then merge the state to use preloaded iframe.
        if (cachedInstance) {
            if (cachedInstance.isReady()) {
                if (typeof config === 'string') {
                    if (cachedInstance.getCachedNetworkName() === config) {
                        return this._merge(cachedInstance);
                    }
                    else {
                        cachedInstance.destroy();
                        cachedInstance = null;
                    }
                }
                else if (config instanceof Object) {
                    if (cachedInstance.getCachedNetworkName() === config.networkName &&
                        !config.xsUri) {
                        return this._merge(cachedInstance);
                    }
                    else {
                        cachedInstance.destroy();
                        cachedInstance = null;
                    }
                }
            }
            else {
                cachedInstance.destroy();
                cachedInstance = null;
            }
        }
    }
    // this merges an authereum instance with this one
    // by copying all properties and connected iframes.
    _merge(instance) {
        this._debug = instance._debug;
        this._apiKey = instance._apiKey;
        this._apiUri = instance._apiUri;
        this._rpcUri = instance._rpcUri;
        this._webUri = instance._webUri;
        this._xsUri = instance._xsUri;
        this._notifierUri = instance._notifierUri;
        this._networkName = instance._networkName;
        this._networkId = instance._networkId;
        this._redirectUri = instance._redirectUri;
        this._iframeConnection = instance._iframeConnection;
        this._childIframeConnection = instance._childIframeConnection;
        this._iframe = instance._iframe;
        this._notificationIframe = instance._notificationIframe;
        this._cacheReady = instance._cacheReady;
        this._cachedLoginKeyAddress = instance._cachedLoginKeyAddress;
        this._cachedAccountAddress = instance._cachedAccountAddress;
        this._cachedIsAuthenticated = instance._cachedIsAuthenticated;
        this._iframeReady = instance._iframeReady;
        this._configReady = instance._configReady;
        this._iframeStyle = instance._iframeStyle;
        this._notificationIframeStyle = instance._notificationIframeStyle;
        this._heartbeatStarted = instance._heartbeatStarted;
        this._backoffTimeout = instance._backoffTimeout;
        this._asymmetricEncryptionKey = instance._asymmetricEncryptionKey;
        this._authereumQueryParams = instance._authereumQueryParams;
        this._injectedElements = instance._injectedElements;
        this._notificationsMap = instance._notificationsMap;
        instance._handlePostMessage = this._handlePostMessage.bind(instance);
        this._initConfig(this._userConfig);
        this._cacheLoginKeyAddress();
        this._getConfigFromChild()
            .then((config) => {
            this._setConfig(config);
            this._postConfigToChild().catch(noop);
            this.emit('iframeReady', {});
        })
            .catch(noop);
        this._emitReadyEvent();
        this._provider = new AuthereumProvider_1.default(this);
        this._refreshWidget();
        return this;
    }
    _setupFocusListener() {
        this.addEventListener('focus', this._handleWindowFocus, false);
    }
    _setupActionKeyListener() {
        this.addEventListener('keydown', this._handleActionKeyPress, false);
    }
    _teardownEventListeners() {
        for (let i = 0; i < this._eventListeners.length; i++) {
            const { type, listener, useCapture } = this._eventListeners[i];
            window.removeEventListener(type, listener, useCapture);
        }
    }
    _getOrCreateMainIframe() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._iframe) {
                if (this._iframeConnection) {
                    this._iframeConnection.destroy();
                }
                this._iframe.remove();
            }
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                const id = 'authereum__x-iframe';
                let el = document.getElementById(id);
                if (el && el.src === this._xsUri) {
                    this._iframe = el;
                }
                else {
                    this._iframe = this._constructIframe({ id, url: this._xsUri });
                    let notificationIframeUrl = `${this._xsUri.replace(/\/$/, '')}/notifications`;
                    this._loadNotificationsIframe(notificationIframeUrl).catch(noop);
                    resolve(this._iframe);
                    yield this._tilDomReady();
                    el = document.getElementById(id);
                    if (el) {
                        el.remove();
                    }
                    document.body.appendChild(this._iframe);
                    this._iframe.onload = () => {
                        this._postVersionToChild().catch(noop);
                        this._loadAsymmetricEncryptionKeyFromChild().catch(noop);
                        this._getConfigFromChild()
                            .then((config) => {
                            if (notificationIframeUrl !== config.notifierIframeUri) {
                                this._loadNotificationsIframe(config.notifierIframeUri);
                            }
                            this._setConfig(config);
                            this._postConfigToChild().catch(noop);
                            this._configReady = true;
                            this.emit('iframeReady', {});
                        })
                            .catch(noop);
                    };
                }
            }));
        });
    }
    _bodyContainsIframe() {
        return document.body.contains(this._iframe);
    }
    _getAuthereumPopupWindow(url) {
        return window.open(url, 'Authereum', `toolbar=no,
      location=no,
      status=no,
      menubar=no,
      scrollbars=no,
      resizable=no,
      width=470,
      height=640`);
    }
    _isAuthereumPopupBlocked(child) {
        return (child === null || child === undefined);
    }
    isPreload() {
        return this._isPreload;
    }
}
exports.default = Authereum;
// keep both static and normal version methods
Authereum.version = () => {
    return version_1.default;
};
if (typeof window !== 'undefined') {
    window.Authereum = Authereum;
    window._authereumInstances = [];
    // disable preloading if param set for debugging
    // if (!getQueryParamValue('debug_disable_preload')) {
    if (utils_1.getQueryParamValue('authereum_debug')) {
        // preload instance in order to avoid async calls between
        // user action and login call.
        let cachedNetwork = 'mainnet';
        const networks = ['kovan', 'goerli', 'rinkeby', 'ropsten'];
        for (let i = 0; i < networks.length; i++) {
            // assuming which network to preload
            if (window.location.href.includes(networks[i])) {
                cachedNetwork = networks[i];
                break;
            }
        }
        const cachedInstance = new Authereum({
            networkName: cachedNetwork,
            isPreload: true
        });
        window._authereumInstances.push(cachedInstance);
    }
}
